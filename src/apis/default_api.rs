/*
 * Beamable API
 *
 * Autogenerated Beamable API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@beamable.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`basic_accounts_admin_admin_user_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAdminAdminUserPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_elevated_account_request: Option<models::CreateElevatedAccountRequest>
}

/// struct for passing parameters to the method [`basic_accounts_admin_admin_users_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAdminAdminUsersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_admin_me_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAdminMeGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_device_id_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableDeviceIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub device_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_external_identity_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableExternalIdentityGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub provider_service: String,
    pub user_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub provider_namespace: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub email: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_third_party_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableThirdPartyGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub third_party: String,
    pub token: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_email_update_confirm_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsEmailUpdateConfirmPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub email_update_confirmation: Option<models::EmailUpdateConfirmation>
}

/// struct for passing parameters to the method [`basic_accounts_email_update_init_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsEmailUpdateInitPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub email_update_request: Option<models::EmailUpdateRequest>
}

/// struct for passing parameters to the method [`basic_accounts_external_identity_delete`]
#[derive(Clone, Debug)]
pub struct BasicAccountsExternalIdentityDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_external_identity_api_request: Option<models::DeleteExternalIdentityApiRequest>
}

/// struct for passing parameters to the method [`basic_accounts_external_identity_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsExternalIdentityPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub attach_external_identity_api_request: Option<models::AttachExternalIdentityApiRequest>
}

/// struct for passing parameters to the method [`basic_accounts_find_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsFindGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub query: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_get_personally_identifiable_information_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsGetPersonallyIdentifiableInformationGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub query: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_me_device_delete`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMeDeviceDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_devices_request: Option<models::DeleteDevicesRequest>
}

/// struct for passing parameters to the method [`basic_accounts_me_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMeGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_me_put`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub account_update: Option<models::AccountUpdate>
}

/// struct for passing parameters to the method [`basic_accounts_me_third_party_delete`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMeThirdPartyDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub third_party_available_request: Option<models::ThirdPartyAvailableRequest>
}

/// struct for passing parameters to the method [`basic_accounts_password_update_confirm_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsPasswordUpdateConfirmPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub password_update_confirmation: Option<models::PasswordUpdateConfirmation>
}

/// struct for passing parameters to the method [`basic_accounts_password_update_init_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsPasswordUpdateInitPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub password_update_request: Option<models::PasswordUpdateRequest>
}

/// struct for passing parameters to the method [`basic_accounts_register_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsRegisterPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub account_registration: Option<models::AccountRegistration>
}

/// struct for passing parameters to the method [`basic_accounts_search_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsSearchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub query: String,
    pub page: i32,
    pub pagesize: i32,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_content_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsContentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_delete`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_announcement_request: Option<models::DeleteAnnouncementRequest>
}

/// struct for passing parameters to the method [`basic_announcements_list_definitions_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsListDefinitionsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_list_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsListGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_list_tags_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsListTagsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tag_name_filter: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_post`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_dto: Option<models::AnnouncementDto>
}

/// struct for passing parameters to the method [`basic_announcements_search_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsSearchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub date: Option<String>
}

/// struct for passing parameters to the method [`basic_auth_token_get`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub token: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_auth_token_list_get`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenListGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub page_size: i32,
    pub page: i32,
    pub gamer_tag_or_account_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cid: Option<i64>,
    pub pid: Option<String>
}

/// struct for passing parameters to the method [`basic_auth_token_post`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub token_request_wrapper: Option<models::TokenRequestWrapper>
}

/// struct for passing parameters to the method [`basic_auth_token_revoke_put`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenRevokePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub revoke_token_request: Option<models::RevokeTokenRequest>
}

/// struct for passing parameters to the method [`basic_beamo_image_commit_put`]
#[derive(Clone, Debug)]
pub struct BasicBeamoImageCommitPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub commit_image_request: Option<models::CommitImageRequest>
}

/// struct for passing parameters to the method [`basic_beamo_image_urls_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoImageUrlsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_service_urls_request: Option<models::GetServiceUrlsRequest>
}

/// struct for passing parameters to the method [`basic_beamo_logs_url_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoLogsUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_logs_url_request: Option<models::GetLogsUrlRequest>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_current_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestCurrentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archived: Option<bool>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_deploy_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestDeployPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archived: Option<bool>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub post_manifest_request: Option<models::PostManifestRequest>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_pull_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestPullPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pull_beamo_manifest_request: Option<models::PullBeamoManifestRequest>
}

/// struct for passing parameters to the method [`basic_beamo_manifests_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub offset: Option<i32>,
    pub limit: Option<i32>,
    pub archived: Option<bool>
}

/// struct for passing parameters to the method [`basic_beamo_metrics_url_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMetricsUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_metrics_url_request: Option<models::GetMetricsUrlRequest>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_federation_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceFederationPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registrations_query: Option<models::MicroserviceRegistrationsQuery>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_federation_traffic_delete`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceFederationTrafficDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registration_request: Option<models::MicroserviceRegistrationRequest>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_federation_traffic_put`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceFederationTrafficPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registration_request: Option<models::MicroserviceRegistrationRequest>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_registrations_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceRegistrationsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registrations_query: Option<models::MicroserviceRegistrationsQuery>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_secret_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceSecretGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_query_logs_delete`]
#[derive(Clone, Debug)]
pub struct BasicBeamoQueryLogsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub query: Option<models::Query>
}

/// struct for passing parameters to the method [`basic_beamo_query_logs_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoQueryLogsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_logs_insight_url_request: Option<models::GetLogsInsightUrlRequest>
}

/// struct for passing parameters to the method [`basic_beamo_query_logs_result_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoQueryLogsResultPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub query: Option<models::Query>
}

/// struct for passing parameters to the method [`basic_beamo_registry_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoRegistryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_status_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoStatusGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_storage_connection_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoStorageConnectionGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_storage_performance_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoStoragePerformanceGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub storage_object_name: String,
    pub granularity: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub end_date: Option<String>,
    pub start_date: Option<String>,
    pub period: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_templates_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoTemplatesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_upload_api_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoUploadApiGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_commit_manifest_put`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataCommitManifestPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_requests: Option<models::UploadRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_delete`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub object_requests: Option<models::ObjectRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_download_url_from_portal_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataDownloadUrlFromPortalPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub object_requests: Option<models::ObjectRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_download_url_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataDownloadUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub object_requests: Option<models::ObjectRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_move_from_portal_put`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataMoveFromPortalPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_basic_cloud_data_request: Option<models::PlayerBasicCloudDataRequest>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_move_put`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataMovePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_basic_cloud_data_request: Option<models::PlayerBasicCloudDataRequest>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_replace_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataReplacePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub replace_objects_request: Option<models::ReplaceObjectsRequest>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_upload_url_from_portal_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataUploadUrlFromPortalPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_requests_from_portal: Option<models::UploadRequestsFromPortal>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_upload_url_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataUploadUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_requests: Option<models::UploadRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_get`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id: Option<i64>
}

/// struct for passing parameters to the method [`basic_commerce_catalog_get`]
#[derive(Clone, Debug)]
pub struct BasicCommerceCatalogGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub version: Option<i64>
}

/// struct for passing parameters to the method [`basic_commerce_catalog_legacy_post`]
#[derive(Clone, Debug)]
pub struct BasicCommerceCatalogLegacyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_catalog_request: Option<models::SaveCatalogRequest>
}

/// struct for passing parameters to the method [`basic_commerce_skus_get`]
#[derive(Clone, Debug)]
pub struct BasicCommerceSkusGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub version: Option<i64>
}

/// struct for passing parameters to the method [`basic_commerce_skus_post`]
#[derive(Clone, Debug)]
pub struct BasicCommerceSkusPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_skus_request: Option<models::SaveSkusRequest>
}

/// struct for passing parameters to the method [`basic_content_binary_post`]
#[derive(Clone, Debug)]
pub struct BasicContentBinaryPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_binary_request: Option<models::SaveBinaryRequest>
}

/// struct for passing parameters to the method [`basic_content_content_get`]
#[derive(Clone, Debug)]
pub struct BasicContentContentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub content_id: String,
    pub version: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_localizations_delete`]
#[derive(Clone, Debug)]
pub struct BasicContentLocalizationsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_localization_request: Option<models::DeleteLocalizationRequest>
}

/// struct for passing parameters to the method [`basic_content_localizations_get`]
#[derive(Clone, Debug)]
pub struct BasicContentLocalizationsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_localizations_put`]
#[derive(Clone, Debug)]
pub struct BasicContentLocalizationsPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub put_localizations_request: Option<models::PutLocalizationsRequest>
}

/// struct for passing parameters to the method [`basic_content_manifest_checksum_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestChecksumGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_checksums_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestChecksumsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_exact_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestExactGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub uid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_history_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestHistoryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub id: Option<String>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`basic_content_manifest_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_manifest_request: Option<models::SaveManifestRequest>
}

/// struct for passing parameters to the method [`basic_content_manifest_private_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPrivateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_private_json_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPrivateJsonGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_public_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPublicGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_public_json_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPublicJsonGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_pull_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPullPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pull_manifest_request: Option<models::PullManifestRequest>
}

/// struct for passing parameters to the method [`basic_content_manifest_repeat_put`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestRepeatPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub repeat_manifest_request: Option<models::RepeatManifestRequest>
}

/// struct for passing parameters to the method [`basic_content_manifests_archive_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsArchivePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archive_or_unarchive_manifests_request: Option<models::ArchiveOrUnarchiveManifestsRequest>
}

/// struct for passing parameters to the method [`basic_content_manifests_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifests_pull_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsPullPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pull_all_manifests_request: Option<models::PullAllManifestsRequest>
}

/// struct for passing parameters to the method [`basic_content_manifests_unarchive_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsUnarchivePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archive_or_unarchive_manifests_request: Option<models::ArchiveOrUnarchiveManifestsRequest>
}

/// struct for passing parameters to the method [`basic_content_post`]
#[derive(Clone, Debug)]
pub struct BasicContentPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_content_request: Option<models::SaveContentRequest>
}

/// struct for passing parameters to the method [`basic_content_text_post`]
#[derive(Clone, Debug)]
pub struct BasicContentTextPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_text_request: Option<models::SaveTextRequest>
}

/// struct for passing parameters to the method [`basic_events_apply_content_post`]
#[derive(Clone, Debug)]
pub struct BasicEventsApplyContentPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_apply_request: Option<models::EventApplyRequest>
}

/// struct for passing parameters to the method [`basic_events_calendar_get`]
#[derive(Clone, Debug)]
pub struct BasicEventsCalendarGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub from: Option<String>,
    pub to: Option<String>,
    pub query: Option<String>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`basic_events_content_get`]
#[derive(Clone, Debug)]
pub struct BasicEventsContentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_events_running_get`]
#[derive(Clone, Debug)]
pub struct BasicEventsRunningGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_inventory_currency_get`]
#[derive(Clone, Debug)]
pub struct BasicInventoryCurrencyGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_inventory_items_get`]
#[derive(Clone, Debug)]
pub struct BasicInventoryItemsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_leaderboards_assignment_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsAssignmentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub board_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub join_board: Option<bool>
}

/// struct for passing parameters to the method [`basic_leaderboards_list_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsListGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub skip: Option<i32>,
    pub limit: Option<i32>,
    pub prefix: Option<String>
}

/// struct for passing parameters to the method [`basic_leaderboards_player_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsPlayerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub dbid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_leaderboards_uid_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsUidGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_mail_attachments_put`]
#[derive(Clone, Debug)]
pub struct BasicMailAttachmentsPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub accept_multiple_attachments: Option<models::AcceptMultipleAttachments>
}

/// struct for passing parameters to the method [`basic_mail_bulk_post`]
#[derive(Clone, Debug)]
pub struct BasicMailBulkPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub bulk_send_mail_request: Option<models::BulkSendMailRequest>
}

/// struct for passing parameters to the method [`basic_mail_get`]
#[derive(Clone, Debug)]
pub struct BasicMailGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub mid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_mail_put`]
#[derive(Clone, Debug)]
pub struct BasicMailPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_mail_request: Option<models::UpdateMailRequest>
}

/// struct for passing parameters to the method [`basic_mail_template_get`]
#[derive(Clone, Debug)]
pub struct BasicMailTemplateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub template_name: String,
    pub gamer_tag: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_notification_channel_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationChannelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_custom_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationCustomPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_game_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationGamePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_generic_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationGenericPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_get`]
#[derive(Clone, Debug)]
pub struct BasicNotificationGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_notification_player_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationPlayerPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_server_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationServerPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub server_event: Option<models::ServerEvent>
}

/// struct for passing parameters to the method [`basic_payments_audits_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsAuditsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub providerid: Option<String>,
    pub provider: Option<String>,
    pub state: Option<String>,
    pub txid: Option<i64>,
    pub player: Option<i64>,
    pub start: Option<i32>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`basic_payments_coupon_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_update_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookUpdateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub hub_mode: String,
    pub hub_challenge: String,
    pub hub_verify_token: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_facebook_update_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookUpdatePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub facebook_payment_update_request: Option<models::FacebookPaymentUpdateRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_auth_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamAuthPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub steam_auth_request: Option<models::SteamAuthRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_order_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamOrderGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub order_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_prices_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPricesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub steam_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_products_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamProductsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub steam_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_push_register_post`]
#[derive(Clone, Debug)]
pub struct BasicPushRegisterPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub register_req: Option<models::RegisterReq>
}

/// struct for passing parameters to the method [`basic_push_send_post`]
#[derive(Clone, Debug)]
pub struct BasicPushSendPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_req: Option<models::SendReq>
}

/// struct for passing parameters to the method [`basic_realms_admin_customer_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsAdminCustomerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_admin_inflight_failures_delete`]
#[derive(Clone, Debug)]
pub struct BasicRealmsAdminInflightFailuresDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub batch_delete_in_flight_request: Option<models::BatchDeleteInFlightRequest>
}

/// struct for passing parameters to the method [`basic_realms_admin_inflight_failures_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsAdminInflightFailuresGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub service_name: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub service_object_id: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_client_defaults_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsClientDefaultsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_config_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsConfigGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_config_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsConfigPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub realm_config_change_request: Option<models::RealmConfigChangeRequest>
}

/// struct for passing parameters to the method [`basic_realms_config_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsConfigPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub realm_config_save_request: Option<models::RealmConfigSaveRequest>
}

/// struct for passing parameters to the method [`basic_realms_customer_alias_available_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerAliasAvailableGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub alias: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_customer_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_customer_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub new_customer_request: Option<models::NewCustomerRequest>
}

/// struct for passing parameters to the method [`basic_realms_customers_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_game_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGameGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub root_pid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_game_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGamePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub new_game_request: Option<models::NewGameRequest>
}

/// struct for passing parameters to the method [`basic_realms_game_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGamePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_game_hierarchy_request: Option<models::UpdateGameHierarchyRequest>
}

/// struct for passing parameters to the method [`basic_realms_games_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGamesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_is_customer_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsIsCustomerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_launch_message_delete`]
#[derive(Clone, Debug)]
pub struct BasicRealmsLaunchMessageDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub remove_launch_message_request: Option<models::RemoveLaunchMessageRequest>
}

/// struct for passing parameters to the method [`basic_realms_launch_message_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsLaunchMessageGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_launch_message_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsLaunchMessagePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_launch_message_request: Option<models::CreateLaunchMessageRequest>
}

/// struct for passing parameters to the method [`basic_realms_plans_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPlansGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_plans_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPlansPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_plan_request: Option<models::CreatePlanRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_beamable_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectBeamablePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_project_request: Option<models::CreateProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_delete`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archive_project_request: Option<models::ArchiveProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_project_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_project_request: Option<models::CreateProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_promote_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPromoteGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub source_pid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promotions: Option<Vec<String>>,
    pub content_manifest_ids: Option<Vec<String>>
}

/// struct for passing parameters to the method [`basic_realms_project_promote_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPromotePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promote_realm_request: Option<models::PromoteRealmRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub unarchive_project_request: Option<models::UnarchiveProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_rename_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectRenamePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub rename_project_request: Option<models::RenameProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_promotion_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPromotionGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub source_pid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promotions: Option<Vec<String>>,
    pub content_manifest_ids: Option<Vec<String>>
}

/// struct for passing parameters to the method [`basic_realms_promotion_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPromotionPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promote_realm_request: Option<models::PromoteRealmRequest>
}

/// struct for passing parameters to the method [`basic_session_client_history_get`]
#[derive(Clone, Debug)]
pub struct BasicSessionClientHistoryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub month: Option<i32>,
    pub year: Option<i32>
}

/// struct for passing parameters to the method [`basic_session_heartbeat_post`]
#[derive(Clone, Debug)]
pub struct BasicSessionHeartbeatPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_session_history_get`]
#[derive(Clone, Debug)]
pub struct BasicSessionHistoryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub dbid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub month: Option<i32>,
    pub year: Option<i32>
}

/// struct for passing parameters to the method [`basic_session_post`]
#[derive(Clone, Debug)]
pub struct BasicSessionPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub start_session_request: Option<models::StartSessionRequest>
}

/// struct for passing parameters to the method [`basic_session_status_get`]
#[derive(Clone, Debug)]
pub struct BasicSessionStatusGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_ids: String,
    pub interval_secs: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_social_blocked_delete`]
#[derive(Clone, Debug)]
pub struct BasicSocialBlockedDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id_request: Option<models::PlayerIdRequest>
}

/// struct for passing parameters to the method [`basic_social_blocked_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialBlockedPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id_request: Option<models::PlayerIdRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_delete`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id_request: Option<models::PlayerIdRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_import_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsImportPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub import_friends_request: Option<models::ImportFriendsRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_invite_delete`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsInviteDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_friend_request: Option<models::SendFriendRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_invite_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsInvitePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_friend_request: Option<models::SendFriendRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_make_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsMakePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub make_friendship_request: Option<models::MakeFriendshipRequest>
}

/// struct for passing parameters to the method [`basic_social_get`]
#[derive(Clone, Debug)]
pub struct BasicSocialGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_ids: Vec<String>,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_social_my_get`]
#[derive(Clone, Debug)]
pub struct BasicSocialMyGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_stats_batch_post`]
#[derive(Clone, Debug)]
pub struct BasicStatsBatchPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub batch_set_stats_request: Option<models::BatchSetStatsRequest>
}

/// struct for passing parameters to the method [`basic_stats_client_batch_get`]
#[derive(Clone, Debug)]
pub struct BasicStatsClientBatchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub object_ids: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats: Option<String>,
    pub format: Option<String>
}

/// struct for passing parameters to the method [`basic_stats_search_extended_post`]
#[derive(Clone, Debug)]
pub struct BasicStatsSearchExtendedPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub search_extended_request: Option<models::SearchExtendedRequest>
}

/// struct for passing parameters to the method [`basic_stats_search_post`]
#[derive(Clone, Debug)]
pub struct BasicStatsSearchPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats_search_request: Option<models::StatsSearchRequest>
}

/// struct for passing parameters to the method [`basic_stats_subscribe_delete`]
#[derive(Clone, Debug)]
pub struct BasicStatsSubscribeDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats_unsubscribe_request: Option<models::StatsUnsubscribeRequest>
}

/// struct for passing parameters to the method [`basic_stats_subscribe_put`]
#[derive(Clone, Debug)]
pub struct BasicStatsSubscribePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats_subscribe_request: Option<models::StatsSubscribeRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_admin_player_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsAdminPlayerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tournament_id: Option<String>,
    pub content_id: Option<String>,
    pub has_unclaimed_rewards: Option<bool>
}

/// struct for passing parameters to the method [`basic_tournaments_admin_player_put`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsAdminPlayerPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_player_status_request: Option<models::UpdatePlayerStatusRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_champions_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsChampionsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    pub cycles: i32,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub is_running: Option<bool>,
    pub content_id: Option<String>,
    pub cycle: Option<i32>
}

/// struct for passing parameters to the method [`basic_tournaments_global_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsGlobalGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_groups_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsGroupsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_me_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsMeGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tournament_id: Option<String>,
    pub content_id: Option<String>,
    pub has_unclaimed_rewards: Option<bool>
}

/// struct for passing parameters to the method [`basic_tournaments_me_group_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsMeGroupGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub join_request: Option<models::JoinRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_rewards_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsRewardsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tournament_id: Option<String>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_rewards_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsRewardsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub rewards_request: Option<models::RewardsRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_score_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsScorePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub score_request: Option<models::ScoreRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_search_groups_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsSearchGroupsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_status_for_groups_request: Option<models::GetStatusForGroupsRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_standings_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsStandingsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_standings_group_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsStandingsGroupGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_admin_data_get`]
#[derive(Clone, Debug)]
pub struct BasicTrialsAdminDataGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_admin_get`]
#[derive(Clone, Debug)]
pub struct BasicTrialsAdminGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub dbid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_data_delete`]
#[derive(Clone, Debug)]
pub struct BasicTrialsDataDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_trial_data_request: Option<models::DeleteTrialDataRequest>
}

/// struct for passing parameters to the method [`basic_trials_data_post`]
#[derive(Clone, Debug)]
pub struct BasicTrialsDataPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_trial_data_request: Option<models::UploadTrialDataRequest>
}

/// struct for passing parameters to the method [`basic_trials_delete`]
#[derive(Clone, Debug)]
pub struct BasicTrialsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_trial_request: Option<models::DeleteTrialRequest>
}

/// struct for passing parameters to the method [`basic_trials_get`]
#[derive(Clone, Debug)]
pub struct BasicTrialsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_pause_put`]
#[derive(Clone, Debug)]
pub struct BasicTrialsPausePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pause_trial_request: Option<models::PauseTrialRequest>
}

/// struct for passing parameters to the method [`basic_trials_post`]
#[derive(Clone, Debug)]
pub struct BasicTrialsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_trial_rest_request: Option<models::CreateTrialRestRequest>
}

/// struct for passing parameters to the method [`basic_trials_schedule_put`]
#[derive(Clone, Debug)]
pub struct BasicTrialsSchedulePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub schedule_trial_request: Option<models::ScheduleTrialRequest>
}

/// struct for passing parameters to the method [`basic_trials_start_put`]
#[derive(Clone, Debug)]
pub struct BasicTrialsStartPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub start_trial_request: Option<models::StartTrialRequest>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_email_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminEmailPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub email_update_request: Option<models::EmailUpdateRequest>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_forget_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminForgetDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_scope_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminScopeDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_role: Option<models::DeleteRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_scope_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminScopePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_role: Option<models::UpdateRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_third_party_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminThirdPartyDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_third_party_association: Option<models::DeleteThirdPartyAssociation>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_third_party_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminThirdPartyPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub transfer_third_party_association: Option<models::TransferThirdPartyAssociation>
}

/// struct for passing parameters to the method [`object_accounts_object_id_available_roles_get`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAvailableRolesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_accounts_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub account_update: Option<models::AccountUpdate>
}

/// struct for passing parameters to the method [`object_accounts_object_id_role_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdRoleDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_role: Option<models::DeleteRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_role_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdRolePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_role: Option<models::UpdateRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_role_report_get`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdRoleReportGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_announcements_object_id_claim_post`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdClaimPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_request: Option<models::AnnouncementRequest>
}

/// struct for passing parameters to the method [`object_announcements_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_request: Option<models::AnnouncementRequest>
}

/// struct for passing parameters to the method [`object_announcements_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub include_deleted: Option<bool>
}

/// struct for passing parameters to the method [`object_announcements_object_id_raw_get`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdRawGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_announcements_object_id_read_put`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdReadPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_request: Option<models::AnnouncementRequest>
}

/// struct for passing parameters to the method [`object_calendars_object_id_claim_post`]
#[derive(Clone, Debug)]
pub struct ObjectCalendarsObjectIdClaimPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub calendar_claim_request: Option<models::CalendarClaimRequest>
}

/// struct for passing parameters to the method [`object_calendars_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectCalendarsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub scope: Option<String>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_messages_post`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdMessagesPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_message_request: Option<models::SendMessageRequest>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_rooms_delete`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdRoomsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leave_room_request: Option<models::LeaveRoomRequest>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_rooms_get`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdRoomsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_rooms_post`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdRoomsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_room_request: Option<models::CreateRoomRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_coupons_count_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdCouponsCountGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_coupons_post`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdCouponsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub give_coupon_req: Option<models::GiveCouponReq>
}

/// struct for passing parameters to the method [`object_commerce_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub scope: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_listings_cooldown_put`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdListingsCooldownPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cooldown_modifier_request: Option<models::CooldownModifierRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_listings_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdListingsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub listing: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub store: Option<String>,
    pub time: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_offers_admin_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdOffersAdminGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub language: Option<String>,
    pub time: Option<String>,
    pub stores: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_offers_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdOffersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub language: Option<String>,
    pub time: Option<String>,
    pub stores: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_purchase_post`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdPurchasePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub purchase_request: Option<models::PurchaseRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_purchase_put`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdPurchasePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub report_purchase_request: Option<models::ReportPurchaseRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_stats_update_post`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdStatsUpdatePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_subscription_notification: Option<models::StatSubscriptionNotification>
}

/// struct for passing parameters to the method [`object_commerce_object_id_status_delete`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdStatusDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub clear_status_request: Option<models::ClearStatusRequest>
}

/// struct for passing parameters to the method [`object_event_players_object_id_claim_post`]
#[derive(Clone, Debug)]
pub struct ObjectEventPlayersObjectIdClaimPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_claim_request: Option<models::EventClaimRequest>
}

/// struct for passing parameters to the method [`object_event_players_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectEventPlayersObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_event_players_object_id_score_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventPlayersObjectIdScorePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_score_request: Option<models::EventScoreRequest>
}

/// struct for passing parameters to the method [`object_events_object_id_content_delete`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdContentDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_events_object_id_content_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdContentPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub set_content_request: Option<models::SetContentRequest>
}

/// struct for passing parameters to the method [`object_events_object_id_end_phase_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdEndPhasePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_phase_end_request: Option<models::EventPhaseEndRequest>
}

/// struct for passing parameters to the method [`object_events_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_events_object_id_ping_get`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdPingGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_events_object_id_refresh_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdRefreshPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_group_users_object_id_availability_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdAvailabilityGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub r#type: models::GroupType,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub name: Option<String>,
    pub tag: Option<String>,
    pub sub_group: Option<bool>
}

/// struct for passing parameters to the method [`object_group_users_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_group_users_object_id_group_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdGroupPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_create: Option<models::GroupCreate>
}

/// struct for passing parameters to the method [`object_group_users_object_id_join_delete`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdJoinDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_membership_request: Option<models::GroupMembershipRequest>
}

/// struct for passing parameters to the method [`object_group_users_object_id_join_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdJoinPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_membership_request: Option<models::GroupMembershipRequest>
}

/// struct for passing parameters to the method [`object_group_users_object_id_recommended_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdRecommendedGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_group_users_object_id_search_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdSearchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub r#type: models::GroupType,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub name: Option<String>,
    pub score_min: Option<i64>,
    pub sort_field: Option<String>,
    pub user_score: Option<i64>,
    pub has_slots: Option<bool>,
    pub enrollment_types: Option<String>,
    pub offset: Option<i32>,
    pub score_max: Option<i64>,
    pub sub_group: Option<bool>,
    pub sort_value: Option<i32>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`object_groups_object_id_apply_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdApplyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_application: Option<models::GroupApplication>
}

/// struct for passing parameters to the method [`object_groups_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub disband_request: Option<models::DisbandRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_donations_claim_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDonationsClaimPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_groups_object_id_donations_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDonationsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_donation_request: Option<models::CreateDonationRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_donations_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDonationsPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub make_donation_request: Option<models::MakeDonationRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_groups_object_id_invite_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdInvitePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_invite: Option<models::GroupInvite>
}

/// struct for passing parameters to the method [`object_groups_object_id_kick_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdKickPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub kick_request: Option<models::KickRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_member_delete`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdMemberDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub kick_request: Option<models::KickRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_petition_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdPetitionPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_application: Option<models::GroupApplication>
}

/// struct for passing parameters to the method [`object_groups_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_update: Option<models::GroupUpdate>
}

/// struct for passing parameters to the method [`object_groups_object_id_role_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdRolePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub role_change_request: Option<models::RoleChangeRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub scope: Option<String>
}

/// struct for passing parameters to the method [`object_inventory_object_id_multipliers_get`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdMultipliersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_inventory_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub inventory_query_request: Option<models::InventoryQueryRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_preview_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdPreviewPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub inventory_update_request: Option<models::InventoryUpdateRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_proxy_reload_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdProxyReloadPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_inventory_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub inventory_update_request: Option<models::InventoryUpdateRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_transaction_delete`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdTransactionDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub end_transaction_request: Option<models::EndTransactionRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_transfer_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdTransferPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub transfer_request: Option<models::TransferRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_assignment_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdAssignmentDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_remove_cache_entry_request: Option<models::LeaderboardRemoveCacheEntryRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_assignment_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdAssignmentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_details_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdDetailsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub from: Option<i32>,
    pub max: Option<i32>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_entries_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdEntriesDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_entry_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdEntryDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_remove_entry_request: Option<models::LeaderboardRemoveEntryRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_entry_put`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdEntryPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_add_request: Option<models::LeaderboardAddRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_freeze_put`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdFreezePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_friends_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdFriendsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_matches_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdMatchesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub pool_size: i32,
    pub windows: i32,
    pub window_size: i32,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_membership_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdMembershipGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_id: i64,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_partition_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdPartitionGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_id: i64,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_create_request: Option<models::LeaderboardCreateRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_ranks_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdRanksGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub ids: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_swap_put`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdSwapPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_swap_request: Option<models::LeaderboardSwapRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_view_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdViewGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub friends: Option<bool>,
    pub from: Option<i32>,
    pub outlier: Option<i64>,
    pub guild: Option<bool>
}

/// struct for passing parameters to the method [`object_mail_object_id_accept_many_put`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdAcceptManyPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub accept_multiple_attachments: Option<models::AcceptMultipleAttachments>
}

/// struct for passing parameters to the method [`object_mail_object_id_bulk_post`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdBulkPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub bulk_send_mail_request: Option<models::BulkSendMailRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_bulk_put`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdBulkPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub bulk_update_mail_object_request: Option<models::BulkUpdateMailObjectRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_categories_get`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdCategoriesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_mail_object_id_detail_get`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdDetailGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub mid: i64,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_mail_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_mail_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_mail_object_request: Option<models::SendMailObjectRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_mail_request: Option<models::UpdateMailRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_search_post`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdSearchPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub mail_search_request: Option<models::MailSearchRequest>
}

/// struct for passing parameters to the method [`object_stats_object_id_client_get`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdClientGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats: Option<String>
}

/// struct for passing parameters to the method [`object_stats_object_id_client_post`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdClientPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_update_request: Option<models::StatUpdateRequest>
}

/// struct for passing parameters to the method [`object_stats_object_id_client_stringlist_post`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdClientStringlistPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_update_request_string_list_format: Option<models::StatUpdateRequestStringListFormat>
}

/// struct for passing parameters to the method [`object_stats_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_request: Option<models::StatRequest>
}

/// struct for passing parameters to the method [`object_stats_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats: Option<String>
}

/// struct for passing parameters to the method [`object_stats_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_update_request: Option<models::StatUpdateRequest>
}


/// struct for typed errors of method [`basic_accounts_admin_admin_user_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAdminAdminUserPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_admin_admin_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAdminAdminUsersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_admin_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAdminMeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_device_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableDeviceIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_external_identity_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableExternalIdentityGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_third_party_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableThirdPartyGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_email_update_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsEmailUpdateConfirmPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_email_update_init_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsEmailUpdateInitPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_external_identity_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsExternalIdentityDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_external_identity_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsExternalIdentityPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_find_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsFindGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_get_personally_identifiable_information_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsGetPersonallyIdentifiableInformationGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_device_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMeDeviceDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_third_party_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMeThirdPartyDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_password_update_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsPasswordUpdateConfirmPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_password_update_init_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsPasswordUpdateInitPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_register_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsRegisterPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsSearchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsContentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_list_definitions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsListDefinitionsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsListGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_list_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsListTagsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsSearchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenListGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_revoke_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenRevokePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_image_commit_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoImageCommitPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_image_urls_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoImageUrlsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_logs_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoLogsUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_current_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestCurrentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_deploy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestDeployPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_pull_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestPullPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_metrics_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMetricsUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_federation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceFederationPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_federation_traffic_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceFederationTrafficDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_federation_traffic_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceFederationTrafficPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_registrations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceRegistrationsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_secret_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceSecretGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_query_logs_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoQueryLogsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_query_logs_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoQueryLogsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_query_logs_result_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoQueryLogsResultPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_registry_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoRegistryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoStatusGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_storage_connection_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoStorageConnectionGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_storage_performance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoStoragePerformanceGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoTemplatesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_upload_api_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoUploadApiGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_commit_manifest_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataCommitManifestPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_download_url_from_portal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataDownloadUrlFromPortalPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_download_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataDownloadUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_move_from_portal_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataMoveFromPortalPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_move_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataMovePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_replace_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataReplacePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_upload_url_from_portal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataUploadUrlFromPortalPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_upload_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataUploadUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_catalog_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceCatalogGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_catalog_legacy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceCatalogLegacyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_skus_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceSkusGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_skus_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceSkusPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_binary_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentBinaryPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentContentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_localizations_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentLocalizationsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_localizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentLocalizationsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_localizations_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentLocalizationsPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_checksum_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestChecksumGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_checksums_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestChecksumsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_exact_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestExactGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestHistoryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_private_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPrivateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_private_json_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPrivateJsonGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_public_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPublicGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_public_json_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPublicJsonGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_pull_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPullPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_repeat_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestRepeatPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_archive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsArchivePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_pull_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsPullPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_unarchive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsUnarchivePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_text_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentTextPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_apply_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsApplyContentPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_calendar_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsCalendarGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsContentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_running_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsRunningGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_inventory_currency_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicInventoryCurrencyGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_inventory_items_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicInventoryItemsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_assignment_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsAssignmentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsListGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_player_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsPlayerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_uid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsUidGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_attachments_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailAttachmentsPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_bulk_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailBulkPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_template_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailTemplateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_channel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationChannelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_custom_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationCustomPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_game_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationGamePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_generic_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationGenericPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_player_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationPlayerPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_server_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationServerPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_audits_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsAuditsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_update_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookUpdateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookUpdatePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_auth_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamAuthPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamOrderGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_prices_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPricesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_products_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamProductsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_push_register_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPushRegisterPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_push_send_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPushSendPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_admin_customer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsAdminCustomerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_admin_inflight_failures_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsAdminInflightFailuresDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_admin_inflight_failures_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsAdminInflightFailuresGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_client_defaults_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsClientDefaultsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsConfigGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_config_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsConfigPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsConfigPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_alias_available_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerAliasAvailableGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_game_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGameGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_game_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGamePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_game_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGamePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_games_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGamesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_is_customer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsIsCustomerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_launch_message_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsLaunchMessageDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_launch_message_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsLaunchMessageGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_launch_message_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsLaunchMessagePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_plans_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPlansGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_plans_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPlansPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_beamable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectBeamablePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_promote_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPromoteGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_promote_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPromotePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_rename_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectRenamePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_promotion_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPromotionGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_promotion_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPromotionPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_client_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionClientHistoryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_heartbeat_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionHeartbeatPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionHistoryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionStatusGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_blocked_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialBlockedDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_blocked_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialBlockedPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsImportPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_invite_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsInviteDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_invite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsInvitePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_make_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsMakePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_my_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialMyGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsBatchPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_client_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsClientBatchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_search_extended_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSearchExtendedPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSearchPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_subscribe_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSubscribeDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_subscribe_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSubscribePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_admin_player_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsAdminPlayerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_admin_player_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsAdminPlayerPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_champions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsChampionsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_global_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsGlobalGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsGroupsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsMeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_me_group_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsMeGroupGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_rewards_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsRewardsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_rewards_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsRewardsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_score_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsScorePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_search_groups_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsSearchGroupsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_standings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsStandingsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_standings_group_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsStandingsGroupGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_admin_data_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsAdminDataGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_admin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsAdminGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_data_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsDataDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_data_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsDataPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_pause_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsPausePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_schedule_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsSchedulePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_start_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsStartPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_email_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminEmailPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_forget_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminForgetDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_scope_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminScopeDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_scope_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminScopePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_third_party_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminThirdPartyDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_third_party_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminThirdPartyPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_available_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAvailableRolesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_role_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdRoleDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_role_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdRolePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_role_report_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdRoleReportGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_claim_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdClaimPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_raw_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdRawGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_read_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdReadPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_calendars_object_id_claim_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCalendarsObjectIdClaimPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_calendars_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCalendarsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_messages_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdMessagesPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_rooms_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdRoomsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_rooms_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdRoomsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_rooms_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdRoomsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_coupons_count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdCouponsCountGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_coupons_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdCouponsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_listings_cooldown_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdListingsCooldownPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_listings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdListingsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_offers_admin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdOffersAdminGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_offers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdOffersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_purchase_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdPurchasePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_purchase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdPurchasePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_stats_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdStatsUpdatePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_status_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdStatusDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_event_players_object_id_claim_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventPlayersObjectIdClaimPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_event_players_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventPlayersObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_event_players_object_id_score_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventPlayersObjectIdScorePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_content_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdContentDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_content_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdContentPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_end_phase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdEndPhasePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_ping_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdPingGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_refresh_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdRefreshPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_availability_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdAvailabilityGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_group_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdGroupPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_join_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdJoinDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_join_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdJoinPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_recommended_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdRecommendedGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdSearchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_apply_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdApplyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_donations_claim_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDonationsClaimPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_donations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDonationsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_donations_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDonationsPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_invite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdInvitePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_kick_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdKickPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_member_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdMemberDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_petition_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdPetitionPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_role_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdRolePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_multipliers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdMultipliersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_preview_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdPreviewPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_proxy_reload_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdProxyReloadPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_transaction_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdTransactionDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_transfer_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdTransferPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_assignment_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdAssignmentDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_assignment_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdAssignmentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdDetailsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_entries_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdEntriesDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_entry_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdEntryDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_entry_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdEntryPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_freeze_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdFreezePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_friends_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdFriendsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_matches_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdMatchesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_membership_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdMembershipGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_partition_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdPartitionGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_ranks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdRanksGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_swap_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdSwapPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_view_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdViewGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_accept_many_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdAcceptManyPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_bulk_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdBulkPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_bulk_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdBulkPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_categories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdCategoriesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_detail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdDetailGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdSearchPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_client_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdClientGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_client_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdClientPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_client_stringlist_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdClientStringlistPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}


pub async fn basic_accounts_admin_admin_user_post(configuration: &configuration::Configuration, params: BasicAccountsAdminAdminUserPostParams) -> Result<models::AccountPortalView, Error<BasicAccountsAdminAdminUserPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_elevated_account_request = params.create_elevated_account_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/admin/admin-user", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_elevated_account_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAdminAdminUserPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_admin_admin_users_get(configuration: &configuration::Configuration, params: BasicAccountsAdminAdminUsersGetParams) -> Result<models::GetAdminsResponse, Error<BasicAccountsAdminAdminUsersGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/admin/admin-users", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAdminAdminUsersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_admin_me_get(configuration: &configuration::Configuration, params: BasicAccountsAdminMeGetParams) -> Result<models::AccountPortalView, Error<BasicAccountsAdminMeGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/admin/me", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAdminMeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_available_device_id_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableDeviceIdGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableDeviceIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let device_id = params.device_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/available/device-id", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("deviceId", &device_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAvailableDeviceIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_available_external_identity_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableExternalIdentityGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableExternalIdentityGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let provider_service = params.provider_service;
    let user_id = params.user_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let provider_namespace = params.provider_namespace;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/available/external_identity", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("provider_service", &provider_service.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("user_id", &user_id.to_string())]);
    if let Some(ref local_var_str) = provider_namespace {
        local_var_req_builder = local_var_req_builder.query(&[("provider_namespace", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAvailableExternalIdentityGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_available_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let email = params.email;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/available", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("email", &email.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAvailableGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_available_third_party_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableThirdPartyGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableThirdPartyGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let third_party = params.third_party;
    let token = params.token;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/available/third-party", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("thirdParty", &third_party.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsAvailableThirdPartyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_email_update_confirm_post(configuration: &configuration::Configuration, params: BasicAccountsEmailUpdateConfirmPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsEmailUpdateConfirmPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let email_update_confirmation = params.email_update_confirmation;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/email-update/confirm", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&email_update_confirmation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsEmailUpdateConfirmPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_email_update_init_post(configuration: &configuration::Configuration, params: BasicAccountsEmailUpdateInitPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsEmailUpdateInitPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let email_update_request = params.email_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/email-update/init", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&email_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsEmailUpdateInitPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_external_identity_delete(configuration: &configuration::Configuration, params: BasicAccountsExternalIdentityDeleteParams) -> Result<models::CommonResponse, Error<BasicAccountsExternalIdentityDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_external_identity_api_request = params.delete_external_identity_api_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/external_identity", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_external_identity_api_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsExternalIdentityDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_external_identity_post(configuration: &configuration::Configuration, params: BasicAccountsExternalIdentityPostParams) -> Result<models::AttachExternalIdentityApiResponse, Error<BasicAccountsExternalIdentityPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let attach_external_identity_api_request = params.attach_external_identity_api_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/external_identity", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&attach_external_identity_api_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsExternalIdentityPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_find_get(configuration: &configuration::Configuration, params: BasicAccountsFindGetParams) -> Result<models::Account, Error<BasicAccountsFindGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let query = params.query;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/find", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsFindGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_get_personally_identifiable_information_get(configuration: &configuration::Configuration, params: BasicAccountsGetPersonallyIdentifiableInformationGetParams) -> Result<models::AccountPersonallyIdentifiableInformationResponse, Error<BasicAccountsGetPersonallyIdentifiableInformationGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let query = params.query;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/get-personally-identifiable-information", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsGetPersonallyIdentifiableInformationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_me_device_delete(configuration: &configuration::Configuration, params: BasicAccountsMeDeviceDeleteParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMeDeviceDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_devices_request = params.delete_devices_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/me/device", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_devices_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsMeDeviceDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_me_get(configuration: &configuration::Configuration, params: BasicAccountsMeGetParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMeGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/me", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsMeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_me_put(configuration: &configuration::Configuration, params: BasicAccountsMePutParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let account_update = params.account_update;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/me", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&account_update);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsMePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_me_third_party_delete(configuration: &configuration::Configuration, params: BasicAccountsMeThirdPartyDeleteParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMeThirdPartyDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let third_party_available_request = params.third_party_available_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/me/third-party", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&third_party_available_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsMeThirdPartyDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_password_update_confirm_post(configuration: &configuration::Configuration, params: BasicAccountsPasswordUpdateConfirmPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsPasswordUpdateConfirmPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let password_update_confirmation = params.password_update_confirmation;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/password-update/confirm", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&password_update_confirmation);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsPasswordUpdateConfirmPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_password_update_init_post(configuration: &configuration::Configuration, params: BasicAccountsPasswordUpdateInitPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsPasswordUpdateInitPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let password_update_request = params.password_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/password-update/init", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&password_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsPasswordUpdateInitPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_register_post(configuration: &configuration::Configuration, params: BasicAccountsRegisterPostParams) -> Result<models::AccountPlayerView, Error<BasicAccountsRegisterPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let account_registration = params.account_registration;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/register", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&account_registration);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsRegisterPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_accounts_search_get(configuration: &configuration::Configuration, params: BasicAccountsSearchGetParams) -> Result<models::AccountSearchResponse, Error<BasicAccountsSearchGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let query = params.query;
    let page = params.page;
    let pagesize = params.pagesize;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/accounts/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("query", &query.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("page", &page.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("pagesize", &pagesize.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAccountsSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_content_get(configuration: &configuration::Configuration, params: BasicAnnouncementsContentGetParams) -> Result<models::AnnouncementContentResponse, Error<BasicAnnouncementsContentGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/content", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsContentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_delete(configuration: &configuration::Configuration, params: BasicAnnouncementsDeleteParams) -> Result<models::EmptyResponse, Error<BasicAnnouncementsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_announcement_request = params.delete_announcement_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_announcement_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_list_definitions_get(configuration: &configuration::Configuration, params: BasicAnnouncementsListDefinitionsGetParams) -> Result<models::ListDefinitionsResponse, Error<BasicAnnouncementsListDefinitionsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/list/definitions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsListDefinitionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_list_get(configuration: &configuration::Configuration, params: BasicAnnouncementsListGetParams) -> Result<models::AnnouncementContentResponse, Error<BasicAnnouncementsListGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_list_tags_get(configuration: &configuration::Configuration, params: BasicAnnouncementsListTagsGetParams) -> Result<models::ListTagsResponse, Error<BasicAnnouncementsListTagsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let tag_name_filter = params.tag_name_filter;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/list/tags", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = tag_name_filter {
        local_var_req_builder = local_var_req_builder.query(&[("tagNameFilter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsListTagsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_post(configuration: &configuration::Configuration, params: BasicAnnouncementsPostParams) -> Result<models::EmptyResponse, Error<BasicAnnouncementsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let announcement_dto = params.announcement_dto;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&announcement_dto);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_announcements_search_get(configuration: &configuration::Configuration, params: BasicAnnouncementsSearchGetParams) -> Result<models::AnnouncementContentResponse, Error<BasicAnnouncementsSearchGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let date = params.date;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/announcements/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = date {
        local_var_req_builder = local_var_req_builder.query(&[("date", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAnnouncementsSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_auth_token_get(configuration: &configuration::Configuration, params: BasicAuthTokenGetParams) -> Result<models::Token, Error<BasicAuthTokenGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let token = params.token;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/auth/token", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("token", &token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAuthTokenGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_auth_token_list_get(configuration: &configuration::Configuration, params: BasicAuthTokenListGetParams) -> Result<models::ListTokenResponse, Error<BasicAuthTokenListGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let page_size = params.page_size;
    let page = params.page;
    let gamer_tag_or_account_id = params.gamer_tag_or_account_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cid = params.cid;
    let pid = params.pid;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/auth/token/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("pageSize", &page_size.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("page", &page.to_string())]);
    if let Some(ref local_var_str) = cid {
        local_var_req_builder = local_var_req_builder.query(&[("cid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = pid {
        local_var_req_builder = local_var_req_builder.query(&[("pid", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("gamerTagOrAccountId", &gamer_tag_or_account_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAuthTokenListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_auth_token_post(configuration: &configuration::Configuration, params: BasicAuthTokenPostParams) -> Result<models::TokenResponse, Error<BasicAuthTokenPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let token_request_wrapper = params.token_request_wrapper;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/auth/token", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&token_request_wrapper);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAuthTokenPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_auth_token_revoke_put(configuration: &configuration::Configuration, params: BasicAuthTokenRevokePutParams) -> Result<models::CommonResponse, Error<BasicAuthTokenRevokePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let revoke_token_request = params.revoke_token_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/auth/token/revoke", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&revoke_token_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicAuthTokenRevokePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_image_commit_put(configuration: &configuration::Configuration, params: BasicBeamoImageCommitPutParams) -> Result<models::LambdaResponse, Error<BasicBeamoImageCommitPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let commit_image_request = params.commit_image_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/image/commit", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&commit_image_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoImageCommitPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_image_urls_post(configuration: &configuration::Configuration, params: BasicBeamoImageUrlsPostParams) -> Result<models::PreSignedUrlsResponse, Error<BasicBeamoImageUrlsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let get_service_urls_request = params.get_service_urls_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/image/urls", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&get_service_urls_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoImageUrlsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_logs_url_post(configuration: &configuration::Configuration, params: BasicBeamoLogsUrlPostParams) -> Result<models::GetSignedUrlResponse, Error<BasicBeamoLogsUrlPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let get_logs_url_request = params.get_logs_url_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/logsUrl", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&get_logs_url_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoLogsUrlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_manifest_current_get(configuration: &configuration::Configuration, params: BasicBeamoManifestCurrentGetParams) -> Result<models::GetCurrentManifestResponse, Error<BasicBeamoManifestCurrentGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let archived = params.archived;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/manifest/current", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = archived {
        local_var_req_builder = local_var_req_builder.query(&[("archived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoManifestCurrentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_manifest_deploy_post(configuration: &configuration::Configuration, params: BasicBeamoManifestDeployPostParams) -> Result<models::EmptyResponse, Error<BasicBeamoManifestDeployPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/manifest/deploy", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoManifestDeployPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_manifest_get(configuration: &configuration::Configuration, params: BasicBeamoManifestGetParams) -> Result<models::GetManifestResponse, Error<BasicBeamoManifestGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let id = params.id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let archived = params.archived;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/manifest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("id", &id.to_string())]);
    if let Some(ref local_var_str) = archived {
        local_var_req_builder = local_var_req_builder.query(&[("archived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoManifestGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_manifest_post(configuration: &configuration::Configuration, params: BasicBeamoManifestPostParams) -> Result<models::PostManifestResponse, Error<BasicBeamoManifestPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let post_manifest_request = params.post_manifest_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/manifest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&post_manifest_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoManifestPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_manifest_pull_post(configuration: &configuration::Configuration, params: BasicBeamoManifestPullPostParams) -> Result<models::BeamoBasicManifestChecksums, Error<BasicBeamoManifestPullPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let pull_beamo_manifest_request = params.pull_beamo_manifest_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/manifest/pull", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&pull_beamo_manifest_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoManifestPullPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_manifests_get(configuration: &configuration::Configuration, params: BasicBeamoManifestsGetParams) -> Result<models::BeamoBasicGetManifestsResponse, Error<BasicBeamoManifestsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let offset = params.offset;
    let limit = params.limit;
    let archived = params.archived;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/manifests", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = archived {
        local_var_req_builder = local_var_req_builder.query(&[("archived", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoManifestsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_metrics_url_post(configuration: &configuration::Configuration, params: BasicBeamoMetricsUrlPostParams) -> Result<models::GetSignedUrlResponse, Error<BasicBeamoMetricsUrlPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let get_metrics_url_request = params.get_metrics_url_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/metricsUrl", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&get_metrics_url_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoMetricsUrlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_microservice_federation_post(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceFederationPostParams) -> Result<models::SupportedFederationsResponse, Error<BasicBeamoMicroserviceFederationPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let microservice_registrations_query = params.microservice_registrations_query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/microservice/federation", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&microservice_registrations_query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoMicroserviceFederationPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_microservice_federation_traffic_delete(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceFederationTrafficDeleteParams) -> Result<models::CommonResponse, Error<BasicBeamoMicroserviceFederationTrafficDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let microservice_registration_request = params.microservice_registration_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/microservice/federation/traffic", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&microservice_registration_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoMicroserviceFederationTrafficDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_microservice_federation_traffic_put(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceFederationTrafficPutParams) -> Result<models::CommonResponse, Error<BasicBeamoMicroserviceFederationTrafficPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let microservice_registration_request = params.microservice_registration_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/microservice/federation/traffic", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&microservice_registration_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoMicroserviceFederationTrafficPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_microservice_registrations_post(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceRegistrationsPostParams) -> Result<models::MicroserviceRegistrationsResponse, Error<BasicBeamoMicroserviceRegistrationsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let microservice_registrations_query = params.microservice_registrations_query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/microservice/registrations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&microservice_registrations_query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoMicroserviceRegistrationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_microservice_secret_get(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceSecretGetParams) -> Result<models::MicroserviceSecretResponse, Error<BasicBeamoMicroserviceSecretGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/microservice/secret", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoMicroserviceSecretGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_query_logs_delete(configuration: &configuration::Configuration, params: BasicBeamoQueryLogsDeleteParams) -> Result<models::CommonResponse, Error<BasicBeamoQueryLogsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let query = params.query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/queryLogs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoQueryLogsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_query_logs_post(configuration: &configuration::Configuration, params: BasicBeamoQueryLogsPostParams) -> Result<models::Query, Error<BasicBeamoQueryLogsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let get_logs_insight_url_request = params.get_logs_insight_url_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/queryLogs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&get_logs_insight_url_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoQueryLogsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_query_logs_result_post(configuration: &configuration::Configuration, params: BasicBeamoQueryLogsResultPostParams) -> Result<models::GetSignedUrlResponse, Error<BasicBeamoQueryLogsResultPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let query = params.query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/queryLogs/result", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&query);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoQueryLogsResultPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_registry_get(configuration: &configuration::Configuration, params: BasicBeamoRegistryGetParams) -> Result<models::GetElasticContainerRegistryUri, Error<BasicBeamoRegistryGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/registry", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoRegistryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_status_get(configuration: &configuration::Configuration, params: BasicBeamoStatusGetParams) -> Result<models::GetStatusResponse, Error<BasicBeamoStatusGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_storage_connection_get(configuration: &configuration::Configuration, params: BasicBeamoStorageConnectionGetParams) -> Result<models::ConnectionString, Error<BasicBeamoStorageConnectionGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/storage/connection", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoStorageConnectionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_storage_performance_get(configuration: &configuration::Configuration, params: BasicBeamoStoragePerformanceGetParams) -> Result<models::PerformanceResponse, Error<BasicBeamoStoragePerformanceGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let storage_object_name = params.storage_object_name;
    let granularity = params.granularity;
    let x_beam_gamertag = params.x_beam_gamertag;
    let end_date = params.end_date;
    let start_date = params.start_date;
    let period = params.period;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/storage/performance", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = end_date {
        local_var_req_builder = local_var_req_builder.query(&[("endDate", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("storageObjectName", &storage_object_name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("granularity", &granularity.to_string())]);
    if let Some(ref local_var_str) = start_date {
        local_var_req_builder = local_var_req_builder.query(&[("startDate", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = period {
        local_var_req_builder = local_var_req_builder.query(&[("period", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoStoragePerformanceGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_templates_get(configuration: &configuration::Configuration, params: BasicBeamoTemplatesGetParams) -> Result<models::GetTemplatesResponse, Error<BasicBeamoTemplatesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/templates", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoTemplatesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_beamo_upload_api_get(configuration: &configuration::Configuration, params: BasicBeamoUploadApiGetParams) -> Result<models::GetLambdaUri, Error<BasicBeamoUploadApiGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/beamo/uploadAPI", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicBeamoUploadApiGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_commit_manifest_put(configuration: &configuration::Configuration, params: BasicCloudsavingDataCommitManifestPutParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataCommitManifestPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let upload_requests = params.upload_requests;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/commitManifest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&upload_requests);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataCommitManifestPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_delete(configuration: &configuration::Configuration, params: BasicCloudsavingDataDeleteParams) -> Result<models::EmptyResponse, Error<BasicCloudsavingDataDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let object_requests = params.object_requests;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object_requests);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_download_url_from_portal_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataDownloadUrlFromPortalPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataDownloadUrlFromPortalPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let object_requests = params.object_requests;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/downloadURLFromPortal", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object_requests);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataDownloadUrlFromPortalPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_download_url_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataDownloadUrlPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataDownloadUrlPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let object_requests = params.object_requests;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/downloadURL", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&object_requests);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataDownloadUrlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_move_from_portal_put(configuration: &configuration::Configuration, params: BasicCloudsavingDataMoveFromPortalPutParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataMoveFromPortalPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let player_basic_cloud_data_request = params.player_basic_cloud_data_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/moveFromPortal", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&player_basic_cloud_data_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataMoveFromPortalPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_move_put(configuration: &configuration::Configuration, params: BasicCloudsavingDataMovePutParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataMovePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let player_basic_cloud_data_request = params.player_basic_cloud_data_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/move", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&player_basic_cloud_data_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataMovePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_replace_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataReplacePostParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataReplacePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let replace_objects_request = params.replace_objects_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/replace", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&replace_objects_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataReplacePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_upload_url_from_portal_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataUploadUrlFromPortalPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataUploadUrlFromPortalPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let upload_requests_from_portal = params.upload_requests_from_portal;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/uploadURLFromPortal", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&upload_requests_from_portal);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataUploadUrlFromPortalPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_data_upload_url_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataUploadUrlPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataUploadUrlPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let upload_requests = params.upload_requests;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/data/uploadURL", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&upload_requests);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingDataUploadUrlPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_cloudsaving_get(configuration: &configuration::Configuration, params: BasicCloudsavingGetParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let player_id = params.player_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/cloudsaving/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = player_id {
        local_var_req_builder = local_var_req_builder.query(&[("playerId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCloudsavingGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_commerce_catalog_get(configuration: &configuration::Configuration, params: BasicCommerceCatalogGetParams) -> Result<models::GetCatalogResponse, Error<BasicCommerceCatalogGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let version = params.version;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/commerce/catalog", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = version {
        local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCommerceCatalogGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_commerce_catalog_legacy_post(configuration: &configuration::Configuration, params: BasicCommerceCatalogLegacyPostParams) -> Result<models::ResultResponse, Error<BasicCommerceCatalogLegacyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let save_catalog_request = params.save_catalog_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/commerce/catalog/legacy", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&save_catalog_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCommerceCatalogLegacyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_commerce_skus_get(configuration: &configuration::Configuration, params: BasicCommerceSkusGetParams) -> Result<models::GetSkusResponse, Error<BasicCommerceSkusGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let version = params.version;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/commerce/skus", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = version {
        local_var_req_builder = local_var_req_builder.query(&[("version", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCommerceSkusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_commerce_skus_post(configuration: &configuration::Configuration, params: BasicCommerceSkusPostParams) -> Result<models::ResultResponse, Error<BasicCommerceSkusPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let save_skus_request = params.save_skus_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/commerce/skus", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&save_skus_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicCommerceSkusPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_binary_post(configuration: &configuration::Configuration, params: BasicContentBinaryPostParams) -> Result<models::SaveBinaryResponse, Error<BasicContentBinaryPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let save_binary_request = params.save_binary_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/binary", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&save_binary_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentBinaryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_content_get(configuration: &configuration::Configuration, params: BasicContentContentGetParams) -> Result<models::ContentOrText, Error<BasicContentContentGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let content_id = params.content_id;
    let version = params.version;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/content", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("contentId", &content_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("version", &version.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentContentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_localizations_delete(configuration: &configuration::Configuration, params: BasicContentLocalizationsDeleteParams) -> Result<models::CommonResponse, Error<BasicContentLocalizationsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_localization_request = params.delete_localization_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/localizations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_localization_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentLocalizationsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_localizations_get(configuration: &configuration::Configuration, params: BasicContentLocalizationsGetParams) -> Result<models::GetLocalizationsResponse, Error<BasicContentLocalizationsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/localizations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentLocalizationsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_localizations_put(configuration: &configuration::Configuration, params: BasicContentLocalizationsPutParams) -> Result<models::CommonResponse, Error<BasicContentLocalizationsPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let put_localizations_request = params.put_localizations_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/localizations", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&put_localizations_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentLocalizationsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_checksum_get(configuration: &configuration::Configuration, params: BasicContentManifestChecksumGetParams) -> Result<models::ContentBasicManifestChecksum, Error<BasicContentManifestChecksumGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/checksum", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestChecksumGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_checksums_get(configuration: &configuration::Configuration, params: BasicContentManifestChecksumsGetParams) -> Result<models::ContentBasicManifestChecksums, Error<BasicContentManifestChecksumsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/checksums", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestChecksumsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_exact_get(configuration: &configuration::Configuration, params: BasicContentManifestExactGetParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestExactGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let uid = params.uid;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/exact", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("uid", &uid.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestExactGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_get(configuration: &configuration::Configuration, params: BasicContentManifestGetParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_history_get(configuration: &configuration::Configuration, params: BasicContentManifestHistoryGetParams) -> Result<models::GetManifestHistoryResponse, Error<BasicContentManifestHistoryGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/history", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestHistoryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_post(configuration: &configuration::Configuration, params: BasicContentManifestPostParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let save_manifest_request = params.save_manifest_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&save_manifest_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_private_get(configuration: &configuration::Configuration, params: BasicContentManifestPrivateGetParams) -> Result<models::ClientManifestResponse, Error<BasicContentManifestPrivateGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/private", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestPrivateGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_private_json_get(configuration: &configuration::Configuration, params: BasicContentManifestPrivateJsonGetParams) -> Result<models::ClientManifestJsonResponse, Error<BasicContentManifestPrivateJsonGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/private/json", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestPrivateJsonGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_public_get(configuration: &configuration::Configuration, params: BasicContentManifestPublicGetParams) -> Result<models::ClientManifestResponse, Error<BasicContentManifestPublicGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/public", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestPublicGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_public_json_get(configuration: &configuration::Configuration, params: BasicContentManifestPublicJsonGetParams) -> Result<models::ClientManifestJsonResponse, Error<BasicContentManifestPublicJsonGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let id = params.id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/public/json", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestPublicJsonGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_pull_post(configuration: &configuration::Configuration, params: BasicContentManifestPullPostParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestPullPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let pull_manifest_request = params.pull_manifest_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/pull", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&pull_manifest_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestPullPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifest_repeat_put(configuration: &configuration::Configuration, params: BasicContentManifestRepeatPutParams) -> Result<models::CommonResponse, Error<BasicContentManifestRepeatPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let repeat_manifest_request = params.repeat_manifest_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifest/repeat", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&repeat_manifest_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestRepeatPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifests_archive_post(configuration: &configuration::Configuration, params: BasicContentManifestsArchivePostParams) -> Result<models::EmptyResponse, Error<BasicContentManifestsArchivePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let archive_or_unarchive_manifests_request = params.archive_or_unarchive_manifests_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifests/archive", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&archive_or_unarchive_manifests_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestsArchivePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifests_get(configuration: &configuration::Configuration, params: BasicContentManifestsGetParams) -> Result<models::ContentBasicGetManifestsResponse, Error<BasicContentManifestsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifests", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifests_pull_post(configuration: &configuration::Configuration, params: BasicContentManifestsPullPostParams) -> Result<models::ContentBasicManifestChecksums, Error<BasicContentManifestsPullPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let pull_all_manifests_request = params.pull_all_manifests_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifests/pull", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&pull_all_manifests_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestsPullPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_manifests_unarchive_post(configuration: &configuration::Configuration, params: BasicContentManifestsUnarchivePostParams) -> Result<models::EmptyResponse, Error<BasicContentManifestsUnarchivePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let archive_or_unarchive_manifests_request = params.archive_or_unarchive_manifests_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/manifests/unarchive", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&archive_or_unarchive_manifests_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentManifestsUnarchivePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_post(configuration: &configuration::Configuration, params: BasicContentPostParams) -> Result<models::SaveContentResponse, Error<BasicContentPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let save_content_request = params.save_content_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&save_content_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_content_text_post(configuration: &configuration::Configuration, params: BasicContentTextPostParams) -> Result<models::SaveTextResponse, Error<BasicContentTextPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let save_text_request = params.save_text_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/content/text", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&save_text_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicContentTextPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_events_apply_content_post(configuration: &configuration::Configuration, params: BasicEventsApplyContentPostParams) -> Result<models::CommonResponse, Error<BasicEventsApplyContentPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let event_apply_request = params.event_apply_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/events/applyContent", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&event_apply_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicEventsApplyContentPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_events_calendar_get(configuration: &configuration::Configuration, params: BasicEventsCalendarGetParams) -> Result<models::EventsInDateRangeResponse, Error<BasicEventsCalendarGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let from = params.from;
    let to = params.to;
    let query = params.query;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/events/calendar", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = to {
        local_var_req_builder = local_var_req_builder.query(&[("to", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = query {
        local_var_req_builder = local_var_req_builder.query(&[("query", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicEventsCalendarGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_events_content_get(configuration: &configuration::Configuration, params: BasicEventsContentGetParams) -> Result<models::EventContentResponse, Error<BasicEventsContentGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/events/content", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicEventsContentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_events_running_get(configuration: &configuration::Configuration, params: BasicEventsRunningGetParams) -> Result<models::EventQueryResponse, Error<BasicEventsRunningGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/events/running", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicEventsRunningGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_inventory_currency_get(configuration: &configuration::Configuration, params: BasicInventoryCurrencyGetParams) -> Result<models::CurrencyContentResponse, Error<BasicInventoryCurrencyGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/inventory/currency", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicInventoryCurrencyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_inventory_items_get(configuration: &configuration::Configuration, params: BasicInventoryItemsGetParams) -> Result<models::ItemContentResponse, Error<BasicInventoryItemsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/inventory/items", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicInventoryItemsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_leaderboards_assignment_get(configuration: &configuration::Configuration, params: BasicLeaderboardsAssignmentGetParams) -> Result<models::LeaderboardAssignmentInfo, Error<BasicLeaderboardsAssignmentGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let board_id = params.board_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let join_board = params.join_board;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/leaderboards/assignment", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("boardId", &board_id.to_string())]);
    if let Some(ref local_var_str) = join_board {
        local_var_req_builder = local_var_req_builder.query(&[("joinBoard", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicLeaderboardsAssignmentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_leaderboards_list_get(configuration: &configuration::Configuration, params: BasicLeaderboardsListGetParams) -> Result<models::LeaderboardListResponse, Error<BasicLeaderboardsListGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let skip = params.skip;
    let limit = params.limit;
    let prefix = params.prefix;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/leaderboards/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = skip {
        local_var_req_builder = local_var_req_builder.query(&[("skip", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = prefix {
        local_var_req_builder = local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicLeaderboardsListGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_leaderboards_player_get(configuration: &configuration::Configuration, params: BasicLeaderboardsPlayerGetParams) -> Result<models::ListLeaderBoardViewResponse, Error<BasicLeaderboardsPlayerGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let dbid = params.dbid;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/leaderboards/player", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dbid", &dbid.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicLeaderboardsPlayerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_leaderboards_uid_get(configuration: &configuration::Configuration, params: BasicLeaderboardsUidGetParams) -> Result<models::LeaderboardUidResponse, Error<BasicLeaderboardsUidGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/leaderboards/uid", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicLeaderboardsUidGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_mail_attachments_put(configuration: &configuration::Configuration, params: BasicMailAttachmentsPutParams) -> Result<models::MailSuccessResponse, Error<BasicMailAttachmentsPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let accept_multiple_attachments = params.accept_multiple_attachments;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/mail/attachments", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&accept_multiple_attachments);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicMailAttachmentsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_mail_bulk_post(configuration: &configuration::Configuration, params: BasicMailBulkPostParams) -> Result<models::MailSuccessResponse, Error<BasicMailBulkPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let bulk_send_mail_request = params.bulk_send_mail_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/mail/bulk", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&bulk_send_mail_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicMailBulkPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_mail_get(configuration: &configuration::Configuration, params: BasicMailGetParams) -> Result<models::MailResponse, Error<BasicMailGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let mid = params.mid;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/mail/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("mid", &mid.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicMailGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_mail_put(configuration: &configuration::Configuration, params: BasicMailPutParams) -> Result<models::MailSuccessResponse, Error<BasicMailPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let update_mail_request = params.update_mail_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/mail/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_mail_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicMailPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_mail_template_get(configuration: &configuration::Configuration, params: BasicMailTemplateGetParams) -> Result<models::MailTemplate, Error<BasicMailTemplateGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let template_name = params.template_name;
    let gamer_tag = params.gamer_tag;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/mail/template", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("templateName", &template_name.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("gamerTag", &gamer_tag.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicMailTemplateGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_channel_post(configuration: &configuration::Configuration, params: BasicNotificationChannelPostParams) -> Result<models::CommonResponse, Error<BasicNotificationChannelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let notification_request = params.notification_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/channel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notification_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationChannelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_custom_post(configuration: &configuration::Configuration, params: BasicNotificationCustomPostParams) -> Result<models::CommonResponse, Error<BasicNotificationCustomPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let notification_request = params.notification_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/custom", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notification_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationCustomPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_game_post(configuration: &configuration::Configuration, params: BasicNotificationGamePostParams) -> Result<models::CommonResponse, Error<BasicNotificationGamePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let notification_request = params.notification_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/game", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notification_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationGamePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_generic_post(configuration: &configuration::Configuration, params: BasicNotificationGenericPostParams) -> Result<models::CommonResponse, Error<BasicNotificationGenericPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let notification_request = params.notification_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/generic", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notification_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationGenericPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_get(configuration: &configuration::Configuration, params: BasicNotificationGetParams) -> Result<models::SubscriberDetailsResponse, Error<BasicNotificationGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_player_post(configuration: &configuration::Configuration, params: BasicNotificationPlayerPostParams) -> Result<models::CommonResponse, Error<BasicNotificationPlayerPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let notification_request = params.notification_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/player", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&notification_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationPlayerPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_notification_server_post(configuration: &configuration::Configuration, params: BasicNotificationServerPostParams) -> Result<models::CommonResponse, Error<BasicNotificationServerPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let server_event = params.server_event;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/notification/server", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&server_event);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicNotificationServerPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_audits_get(configuration: &configuration::Configuration, params: BasicPaymentsAuditsGetParams) -> Result<models::ListAuditResponse, Error<BasicPaymentsAuditsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let providerid = params.providerid;
    let provider = params.provider;
    let state = params.state;
    let txid = params.txid;
    let player = params.player;
    let start = params.start;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/audits", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = providerid {
        local_var_req_builder = local_var_req_builder.query(&[("providerid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = provider {
        local_var_req_builder = local_var_req_builder.query(&[("provider", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = state {
        local_var_req_builder = local_var_req_builder.query(&[("state", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = txid {
        local_var_req_builder = local_var_req_builder.query(&[("txid", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = player {
        local_var_req_builder = local_var_req_builder.query(&[("player", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsAuditsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_product_get(configuration: &configuration::Configuration, params: BasicPaymentsCouponProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsCouponProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsCouponPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_coupon_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/coupon/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsCouponPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_product_get(configuration: &configuration::Configuration, params: BasicPaymentsFacebookProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsFacebookProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsFacebookPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_update_get(configuration: &configuration::Configuration, params: BasicPaymentsFacebookUpdateGetParams) -> Result<models::SubscriptionVerificationResponse, Error<BasicPaymentsFacebookUpdateGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let hub_mode = params.hub_mode;
    let hub_challenge = params.hub_challenge;
    let hub_verify_token = params.hub_verify_token;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/update", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("hubMode", &hub_mode.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("hubChallenge", &hub_challenge.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("hubVerifyToken", &hub_verify_token.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookUpdateGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_facebook_update_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookUpdatePostParams) -> Result<models::FacebookPaymentUpdateResponse, Error<BasicPaymentsFacebookUpdatePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let facebook_payment_update_request = params.facebook_payment_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/facebook/update", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&facebook_payment_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsFacebookUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_product_get(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsGoogleplayProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsGoogleplayPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_googleplay_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/googleplay/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsGoogleplayPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_product_get(configuration: &configuration::Configuration, params: BasicPaymentsItunesProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsItunesProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsItunesPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_itunes_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/itunes/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsItunesPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_auth_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamAuthPostParams) -> Result<models::EmptyResponse, Error<BasicPaymentsSteamAuthPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let steam_auth_request = params.steam_auth_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/auth", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&steam_auth_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamAuthPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_order_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamOrderGetParams) -> Result<models::SteamOrderInfoResponse, Error<BasicPaymentsSteamOrderGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let order_id = params.order_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/order", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("orderId", &order_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamOrderGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_prices_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamPricesGetParams) -> Result<models::LocalizedPriceMap, Error<BasicPaymentsSteamPricesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let steam_id = params.steam_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/prices", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("steamId", &steam_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPricesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_product_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsSteamProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_products_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamProductsGetParams) -> Result<models::GetProductsResponse, Error<BasicPaymentsSteamProductsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let steam_id = params.steam_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/products", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("steamId", &steam_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamProductsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsSteamPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_steam_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/steam/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsSteamPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_product_get(configuration: &configuration::Configuration, params: BasicPaymentsTestProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsTestProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsTestPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_test_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/test/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsTestPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_product_get(configuration: &configuration::Configuration, params: BasicPaymentsWindowsProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsWindowsProductGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let sku = params.sku;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/product", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sku", &sku.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsProductGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsWindowsPurchaseBeginPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let begin_purchase_request = params.begin_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/purchase/begin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&begin_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsPurchaseBeginPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseCancelPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cancel_purchase_request = params.cancel_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/purchase/cancel", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cancel_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsPurchaseCancelPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseCompletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let complete_purchase_request = params.complete_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/purchase/complete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&complete_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsPurchaseCompletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseFailPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let fail_purchase_request = params.fail_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/purchase/fail", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&fail_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsPurchaseFailPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseTrackPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let track_purchase_request = params.track_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/purchase/track", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&track_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsPurchaseTrackPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_payments_windows_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseVerifyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let verify_purchase_request = params.verify_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/payments/windows/purchase/verify", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&verify_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPaymentsWindowsPurchaseVerifyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_push_register_post(configuration: &configuration::Configuration, params: BasicPushRegisterPostParams) -> Result<serde_json::Value, Error<BasicPushRegisterPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let register_req = params.register_req;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/push/register", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&register_req);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPushRegisterPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_push_send_post(configuration: &configuration::Configuration, params: BasicPushSendPostParams) -> Result<serde_json::Value, Error<BasicPushSendPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let send_req = params.send_req;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/push/send", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&send_req);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicPushSendPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_admin_customer_get(configuration: &configuration::Configuration, params: BasicRealmsAdminCustomerGetParams) -> Result<models::CustomerResponse, Error<BasicRealmsAdminCustomerGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/admin/customer", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsAdminCustomerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_admin_inflight_failures_delete(configuration: &configuration::Configuration, params: BasicRealmsAdminInflightFailuresDeleteParams) -> Result<models::CommonResponse, Error<BasicRealmsAdminInflightFailuresDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let batch_delete_in_flight_request = params.batch_delete_in_flight_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/admin/inflight/failures", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&batch_delete_in_flight_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsAdminInflightFailuresDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_admin_inflight_failures_get(configuration: &configuration::Configuration, params: BasicRealmsAdminInflightFailuresGetParams) -> Result<models::InFlightFailureResponse, Error<BasicRealmsAdminInflightFailuresGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let service_name = params.service_name;
    let x_beam_gamertag = params.x_beam_gamertag;
    let service_object_id = params.service_object_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/admin/inflight/failures", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = service_object_id {
        local_var_req_builder = local_var_req_builder.query(&[("serviceObjectId", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("serviceName", &service_name.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsAdminInflightFailuresGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_client_defaults_get(configuration: &configuration::Configuration, params: BasicRealmsClientDefaultsGetParams) -> Result<models::RealmConfiguration, Error<BasicRealmsClientDefaultsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/client/defaults", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsClientDefaultsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_config_get(configuration: &configuration::Configuration, params: BasicRealmsConfigGetParams) -> Result<models::RealmConfigResponse, Error<BasicRealmsConfigGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsConfigGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_config_post(configuration: &configuration::Configuration, params: BasicRealmsConfigPostParams) -> Result<models::CommonResponse, Error<BasicRealmsConfigPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let realm_config_change_request = params.realm_config_change_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&realm_config_change_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsConfigPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_config_put(configuration: &configuration::Configuration, params: BasicRealmsConfigPutParams) -> Result<models::CommonResponse, Error<BasicRealmsConfigPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let realm_config_save_request = params.realm_config_save_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/config", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&realm_config_save_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsConfigPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_customer_alias_available_get(configuration: &configuration::Configuration, params: BasicRealmsCustomerAliasAvailableGetParams) -> Result<models::AliasAvailableResponse, Error<BasicRealmsCustomerAliasAvailableGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let alias = params.alias;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/customer/alias/available", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("alias", &alias.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsCustomerAliasAvailableGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_customer_get(configuration: &configuration::Configuration, params: BasicRealmsCustomerGetParams) -> Result<models::CustomerViewResponse, Error<BasicRealmsCustomerGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/customer", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsCustomerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_customer_post(configuration: &configuration::Configuration, params: BasicRealmsCustomerPostParams) -> Result<models::NewCustomerResponse, Error<BasicRealmsCustomerPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let new_customer_request = params.new_customer_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/customer", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&new_customer_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsCustomerPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_customers_get(configuration: &configuration::Configuration, params: BasicRealmsCustomersGetParams) -> Result<models::CustomersResponse, Error<BasicRealmsCustomersGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/customers", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsCustomersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_game_get(configuration: &configuration::Configuration, params: BasicRealmsGameGetParams) -> Result<models::GetGameResponse, Error<BasicRealmsGameGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let root_pid = params.root_pid;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/game", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("rootPID", &root_pid.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsGameGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_game_post(configuration: &configuration::Configuration, params: BasicRealmsGamePostParams) -> Result<models::CommonResponse, Error<BasicRealmsGamePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let new_game_request = params.new_game_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/game", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&new_game_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsGamePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_game_put(configuration: &configuration::Configuration, params: BasicRealmsGamePutParams) -> Result<models::CommonResponse, Error<BasicRealmsGamePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let update_game_hierarchy_request = params.update_game_hierarchy_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/game", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_game_hierarchy_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsGamePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_games_get(configuration: &configuration::Configuration, params: BasicRealmsGamesGetParams) -> Result<models::GetGameResponse, Error<BasicRealmsGamesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/games", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsGamesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_is_customer_get(configuration: &configuration::Configuration, params: BasicRealmsIsCustomerGetParams) -> Result<models::EmptyResponse, Error<BasicRealmsIsCustomerGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/is-customer", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsIsCustomerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_launch_message_delete(configuration: &configuration::Configuration, params: BasicRealmsLaunchMessageDeleteParams) -> Result<models::CommonResponse, Error<BasicRealmsLaunchMessageDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let remove_launch_message_request = params.remove_launch_message_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/launch-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&remove_launch_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsLaunchMessageDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_launch_message_get(configuration: &configuration::Configuration, params: BasicRealmsLaunchMessageGetParams) -> Result<models::LaunchMessageListResponse, Error<BasicRealmsLaunchMessageGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/launch-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsLaunchMessageGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_launch_message_post(configuration: &configuration::Configuration, params: BasicRealmsLaunchMessagePostParams) -> Result<models::CommonResponse, Error<BasicRealmsLaunchMessagePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_launch_message_request = params.create_launch_message_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/launch-message", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_launch_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsLaunchMessagePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_plans_get(configuration: &configuration::Configuration, params: BasicRealmsPlansGetParams) -> Result<models::ServicePlansResponse, Error<BasicRealmsPlansGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/plans", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsPlansGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_plans_post(configuration: &configuration::Configuration, params: BasicRealmsPlansPostParams) -> Result<models::CommonResponse, Error<BasicRealmsPlansPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_plan_request = params.create_plan_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/plans", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_plan_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsPlansPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_beamable_post(configuration: &configuration::Configuration, params: BasicRealmsProjectBeamablePostParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectBeamablePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_project_request = params.create_project_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project/beamable", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_project_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectBeamablePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_delete(configuration: &configuration::Configuration, params: BasicRealmsProjectDeleteParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let archive_project_request = params.archive_project_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&archive_project_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_get(configuration: &configuration::Configuration, params: BasicRealmsProjectGetParams) -> Result<models::ProjectView, Error<BasicRealmsProjectGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_post(configuration: &configuration::Configuration, params: BasicRealmsProjectPostParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_project_request = params.create_project_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_project_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_promote_get(configuration: &configuration::Configuration, params: BasicRealmsProjectPromoteGetParams) -> Result<models::PromoteRealmResponseOld, Error<BasicRealmsProjectPromoteGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let source_pid = params.source_pid;
    let x_beam_gamertag = params.x_beam_gamertag;
    let promotions = params.promotions;
    let content_manifest_ids = params.content_manifest_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project/promote", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sourcePid", &source_pid.to_string())]);
    if let Some(ref local_var_str) = promotions {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("promotions".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("promotions", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = content_manifest_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("contentManifestIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("contentManifestIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectPromoteGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_promote_post(configuration: &configuration::Configuration, params: BasicRealmsProjectPromotePostParams) -> Result<models::PromoteRealmResponseOld, Error<BasicRealmsProjectPromotePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let promote_realm_request = params.promote_realm_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project/promote", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&promote_realm_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectPromotePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_put(configuration: &configuration::Configuration, params: BasicRealmsProjectPutParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let unarchive_project_request = params.unarchive_project_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&unarchive_project_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_project_rename_put(configuration: &configuration::Configuration, params: BasicRealmsProjectRenamePutParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectRenamePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let rename_project_request = params.rename_project_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/project/rename", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rename_project_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsProjectRenamePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_promotion_get(configuration: &configuration::Configuration, params: BasicRealmsPromotionGetParams) -> Result<models::PromoteRealmResponse, Error<BasicRealmsPromotionGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let source_pid = params.source_pid;
    let x_beam_gamertag = params.x_beam_gamertag;
    let promotions = params.promotions;
    let content_manifest_ids = params.content_manifest_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/promotion", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sourcePid", &source_pid.to_string())]);
    if let Some(ref local_var_str) = promotions {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("promotions".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("promotions", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = content_manifest_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("contentManifestIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("contentManifestIds", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsPromotionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_realms_promotion_post(configuration: &configuration::Configuration, params: BasicRealmsPromotionPostParams) -> Result<models::PromoteRealmResponse, Error<BasicRealmsPromotionPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let promote_realm_request = params.promote_realm_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/realms/promotion", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&promote_realm_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicRealmsPromotionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_session_client_history_get(configuration: &configuration::Configuration, params: BasicSessionClientHistoryGetParams) -> Result<models::SessionClientHistoryResponse, Error<BasicSessionClientHistoryGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let month = params.month;
    let year = params.year;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/session/client/history", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = month {
        local_var_req_builder = local_var_req_builder.query(&[("month", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = year {
        local_var_req_builder = local_var_req_builder.query(&[("year", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSessionClientHistoryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_session_heartbeat_post(configuration: &configuration::Configuration, params: BasicSessionHeartbeatPostParams) -> Result<models::SessionHeartbeat, Error<BasicSessionHeartbeatPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/session/heartbeat", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSessionHeartbeatPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_session_history_get(configuration: &configuration::Configuration, params: BasicSessionHistoryGetParams) -> Result<models::SessionHistoryResponse, Error<BasicSessionHistoryGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let dbid = params.dbid;
    let x_beam_gamertag = params.x_beam_gamertag;
    let month = params.month;
    let year = params.year;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/session/history", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dbid", &dbid.to_string())]);
    if let Some(ref local_var_str) = month {
        local_var_req_builder = local_var_req_builder.query(&[("month", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = year {
        local_var_req_builder = local_var_req_builder.query(&[("year", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSessionHistoryGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_session_post(configuration: &configuration::Configuration, params: BasicSessionPostParams) -> Result<models::StartSessionResponse, Error<BasicSessionPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let start_session_request = params.start_session_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/session/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&start_session_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSessionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_session_status_get(configuration: &configuration::Configuration, params: BasicSessionStatusGetParams) -> Result<models::OnlineStatusResponses, Error<BasicSessionStatusGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let player_ids = params.player_ids;
    let interval_secs = params.interval_secs;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/session/status", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("playerIds", &player_ids.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("intervalSecs", &interval_secs.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSessionStatusGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_blocked_delete(configuration: &configuration::Configuration, params: BasicSocialBlockedDeleteParams) -> Result<models::FriendshipStatus, Error<BasicSocialBlockedDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let player_id_request = params.player_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/blocked", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&player_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialBlockedDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_blocked_post(configuration: &configuration::Configuration, params: BasicSocialBlockedPostParams) -> Result<models::FriendshipStatus, Error<BasicSocialBlockedPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let player_id_request = params.player_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/blocked", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&player_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialBlockedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_friends_delete(configuration: &configuration::Configuration, params: BasicSocialFriendsDeleteParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let player_id_request = params.player_id_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/friends", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&player_id_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialFriendsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_friends_import_post(configuration: &configuration::Configuration, params: BasicSocialFriendsImportPostParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsImportPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let import_friends_request = params.import_friends_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/friends/import", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&import_friends_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialFriendsImportPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_friends_invite_delete(configuration: &configuration::Configuration, params: BasicSocialFriendsInviteDeleteParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsInviteDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let send_friend_request = params.send_friend_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/friends/invite", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&send_friend_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialFriendsInviteDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_friends_invite_post(configuration: &configuration::Configuration, params: BasicSocialFriendsInvitePostParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsInvitePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let send_friend_request = params.send_friend_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/friends/invite", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&send_friend_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialFriendsInvitePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_friends_make_post(configuration: &configuration::Configuration, params: BasicSocialFriendsMakePostParams) -> Result<models::CommonResponse, Error<BasicSocialFriendsMakePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let make_friendship_request = params.make_friendship_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/friends/make", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&make_friendship_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialFriendsMakePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_get(configuration: &configuration::Configuration, params: BasicSocialGetParams) -> Result<models::GetSocialStatusesResponse, Error<BasicSocialGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let player_ids = params.player_ids;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&player_ids.into_iter().map(|p| ("playerIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("playerIds", &player_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_social_my_get(configuration: &configuration::Configuration, params: BasicSocialMyGetParams) -> Result<models::Social, Error<BasicSocialMyGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/social/my", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicSocialMyGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_stats_batch_post(configuration: &configuration::Configuration, params: BasicStatsBatchPostParams) -> Result<models::EmptyResponse, Error<BasicStatsBatchPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let batch_set_stats_request = params.batch_set_stats_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/stats/batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&batch_set_stats_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicStatsBatchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_stats_client_batch_get(configuration: &configuration::Configuration, params: BasicStatsClientBatchGetParams) -> Result<models::BatchReadStatsResponse, Error<BasicStatsClientBatchGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_ids = params.object_ids;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stats = params.stats;
    let format = params.format;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/stats/client/batch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("objectIds", &object_ids.to_string())]);
    if let Some(ref local_var_str) = stats {
        local_var_req_builder = local_var_req_builder.query(&[("stats", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = format {
        local_var_req_builder = local_var_req_builder.query(&[("format", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicStatsClientBatchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_stats_search_extended_post(configuration: &configuration::Configuration, params: BasicStatsSearchExtendedPostParams) -> Result<models::SearchExtendedResponse, Error<BasicStatsSearchExtendedPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let search_extended_request = params.search_extended_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/stats/search/extended", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&search_extended_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicStatsSearchExtendedPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_stats_search_post(configuration: &configuration::Configuration, params: BasicStatsSearchPostParams) -> Result<models::StatsSearchResponse, Error<BasicStatsSearchPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stats_search_request = params.stats_search_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/stats/search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stats_search_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicStatsSearchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_stats_subscribe_delete(configuration: &configuration::Configuration, params: BasicStatsSubscribeDeleteParams) -> Result<models::CommonResponse, Error<BasicStatsSubscribeDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stats_unsubscribe_request = params.stats_unsubscribe_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/stats/subscribe", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stats_unsubscribe_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicStatsSubscribeDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_stats_subscribe_put(configuration: &configuration::Configuration, params: BasicStatsSubscribePutParams) -> Result<models::CommonResponse, Error<BasicStatsSubscribePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stats_subscribe_request = params.stats_subscribe_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/stats/subscribe", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stats_subscribe_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicStatsSubscribePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_admin_player_get(configuration: &configuration::Configuration, params: BasicTournamentsAdminPlayerGetParams) -> Result<models::AdminGetPlayerStatusResponse, Error<BasicTournamentsAdminPlayerGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let player_id = params.player_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let tournament_id = params.tournament_id;
    let content_id = params.content_id;
    let has_unclaimed_rewards = params.has_unclaimed_rewards;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/admin/player", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("playerId", &player_id.to_string())]);
    if let Some(ref local_var_str) = tournament_id {
        local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_unclaimed_rewards {
        local_var_req_builder = local_var_req_builder.query(&[("hasUnclaimedRewards", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsAdminPlayerGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_admin_player_put(configuration: &configuration::Configuration, params: BasicTournamentsAdminPlayerPutParams) -> Result<models::AdminPlayerStatus, Error<BasicTournamentsAdminPlayerPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let update_player_status_request = params.update_player_status_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/admin/player", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_player_status_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsAdminPlayerPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_champions_get(configuration: &configuration::Configuration, params: BasicTournamentsChampionsGetParams) -> Result<models::GetChampionsResponse, Error<BasicTournamentsChampionsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let tournament_id = params.tournament_id;
    let cycles = params.cycles;
    let x_beam_gamertag = params.x_beam_gamertag;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/champions", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &tournament_id.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("cycles", &cycles.to_string())]);
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsChampionsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_get(configuration: &configuration::Configuration, params: BasicTournamentsGetParams) -> Result<models::TournamentQueryResponse, Error<BasicTournamentsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let is_running = params.is_running;
    let content_id = params.content_id;
    let cycle = params.cycle;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_running {
        local_var_req_builder = local_var_req_builder.query(&[("isRunning", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cycle {
        local_var_req_builder = local_var_req_builder.query(&[("cycle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_global_get(configuration: &configuration::Configuration, params: BasicTournamentsGlobalGetParams) -> Result<models::GetStandingsResponse, Error<BasicTournamentsGlobalGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let tournament_id = params.tournament_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let max = params.max;
    let focus = params.focus;
    let cycle = params.cycle;
    let from = params.from;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/global", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &tournament_id.to_string())]);
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = focus {
        local_var_req_builder = local_var_req_builder.query(&[("focus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cycle {
        local_var_req_builder = local_var_req_builder.query(&[("cycle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsGlobalGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_groups_get(configuration: &configuration::Configuration, params: BasicTournamentsGroupsGetParams) -> Result<models::GetGroupsResponse, Error<BasicTournamentsGroupsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let tournament_id = params.tournament_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let max = params.max;
    let focus = params.focus;
    let cycle = params.cycle;
    let from = params.from;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/groups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &tournament_id.to_string())]);
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = focus {
        local_var_req_builder = local_var_req_builder.query(&[("focus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cycle {
        local_var_req_builder = local_var_req_builder.query(&[("cycle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsGroupsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_me_get(configuration: &configuration::Configuration, params: BasicTournamentsMeGetParams) -> Result<models::GetPlayerStatusResponse, Error<BasicTournamentsMeGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let tournament_id = params.tournament_id;
    let content_id = params.content_id;
    let has_unclaimed_rewards = params.has_unclaimed_rewards;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/me", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = tournament_id {
        local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_unclaimed_rewards {
        local_var_req_builder = local_var_req_builder.query(&[("hasUnclaimedRewards", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsMeGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_me_group_get(configuration: &configuration::Configuration, params: BasicTournamentsMeGroupGetParams) -> Result<models::GetGroupStatusResponse, Error<BasicTournamentsMeGroupGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/me/group", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsMeGroupGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_post(configuration: &configuration::Configuration, params: BasicTournamentsPostParams) -> Result<models::PlayerStatus, Error<BasicTournamentsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let join_request = params.join_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&join_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_rewards_get(configuration: &configuration::Configuration, params: BasicTournamentsRewardsGetParams) -> Result<models::RewardsResponse, Error<BasicTournamentsRewardsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let tournament_id = params.tournament_id;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/rewards", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = tournament_id {
        local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsRewardsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_rewards_post(configuration: &configuration::Configuration, params: BasicTournamentsRewardsPostParams) -> Result<models::RewardsResponse, Error<BasicTournamentsRewardsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let rewards_request = params.rewards_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/rewards", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&rewards_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsRewardsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_score_post(configuration: &configuration::Configuration, params: BasicTournamentsScorePostParams) -> Result<models::EmptyResponse, Error<BasicTournamentsScorePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let score_request = params.score_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/score", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&score_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsScorePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_search_groups_post(configuration: &configuration::Configuration, params: BasicTournamentsSearchGroupsPostParams) -> Result<models::GetStatusForGroupsResponse, Error<BasicTournamentsSearchGroupsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let get_status_for_groups_request = params.get_status_for_groups_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/search/groups", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&get_status_for_groups_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsSearchGroupsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_standings_get(configuration: &configuration::Configuration, params: BasicTournamentsStandingsGetParams) -> Result<models::GetStandingsResponse, Error<BasicTournamentsStandingsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let tournament_id = params.tournament_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let max = params.max;
    let focus = params.focus;
    let cycle = params.cycle;
    let from = params.from;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/standings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &tournament_id.to_string())]);
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = focus {
        local_var_req_builder = local_var_req_builder.query(&[("focus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cycle {
        local_var_req_builder = local_var_req_builder.query(&[("cycle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsStandingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_tournaments_standings_group_get(configuration: &configuration::Configuration, params: BasicTournamentsStandingsGroupGetParams) -> Result<models::GetStandingsResponse, Error<BasicTournamentsStandingsGroupGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let tournament_id = params.tournament_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let max = params.max;
    let focus = params.focus;
    let cycle = params.cycle;
    let from = params.from;
    let content_id = params.content_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/tournaments/standings/group", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("tournamentId", &tournament_id.to_string())]);
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = focus {
        local_var_req_builder = local_var_req_builder.query(&[("focus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cycle {
        local_var_req_builder = local_var_req_builder.query(&[("cycle", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = content_id {
        local_var_req_builder = local_var_req_builder.query(&[("contentId", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTournamentsStandingsGroupGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_admin_data_get(configuration: &configuration::Configuration, params: BasicTrialsAdminDataGetParams) -> Result<models::GetS3DataResponse, Error<BasicTrialsAdminDataGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let id = params.id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/admin/data", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("id", &id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsAdminDataGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_admin_get(configuration: &configuration::Configuration, params: BasicTrialsAdminGetParams) -> Result<models::GetPlayerTrialsResponse, Error<BasicTrialsAdminGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let dbid = params.dbid;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/admin", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("dbid", &dbid.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsAdminGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_data_delete(configuration: &configuration::Configuration, params: BasicTrialsDataDeleteParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsDataDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_trial_data_request = params.delete_trial_data_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/data", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_trial_data_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsDataDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_data_post(configuration: &configuration::Configuration, params: BasicTrialsDataPostParams) -> Result<models::SaveGameDataResponse, Error<BasicTrialsDataPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let upload_trial_data_request = params.upload_trial_data_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/data", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&upload_trial_data_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsDataPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_delete(configuration: &configuration::Configuration, params: BasicTrialsDeleteParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_trial_request = params.delete_trial_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_trial_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_get(configuration: &configuration::Configuration, params: BasicTrialsGetParams) -> Result<models::ListTrialsResponse, Error<BasicTrialsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_pause_put(configuration: &configuration::Configuration, params: BasicTrialsPausePutParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsPausePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let pause_trial_request = params.pause_trial_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/pause", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&pause_trial_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsPausePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_post(configuration: &configuration::Configuration, params: BasicTrialsPostParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_trial_rest_request = params.create_trial_rest_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_trial_rest_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_schedule_put(configuration: &configuration::Configuration, params: BasicTrialsSchedulePutParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsSchedulePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let schedule_trial_request = params.schedule_trial_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/schedule", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&schedule_trial_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsSchedulePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn basic_trials_start_put(configuration: &configuration::Configuration, params: BasicTrialsStartPutParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsStartPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let x_beam_gamertag = params.x_beam_gamertag;
    let start_trial_request = params.start_trial_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/basic/trials/start", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&start_trial_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BasicTrialsStartPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_admin_email_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminEmailPutParams) -> Result<models::Account, Error<ObjectAccountsObjectIdAdminEmailPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let email_update_request = params.email_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/admin/email", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&email_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAdminEmailPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_admin_forget_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminForgetDeleteParams) -> Result<models::Account, Error<ObjectAccountsObjectIdAdminForgetDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/admin/forget", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAdminForgetDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_admin_scope_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminScopeDeleteParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminScopeDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_role = params.delete_role;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/admin/scope", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_role);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAdminScopeDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_admin_scope_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminScopePutParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminScopePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let update_role = params.update_role;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/admin/scope", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_role);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAdminScopePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_admin_third_party_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminThirdPartyDeleteParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminThirdPartyDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_third_party_association = params.delete_third_party_association;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/admin/third-party", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_third_party_association);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAdminThirdPartyDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_admin_third_party_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminThirdPartyPutParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminThirdPartyPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let transfer_third_party_association = params.transfer_third_party_association;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/admin/third-party", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&transfer_third_party_association);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAdminThirdPartyPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_available_roles_get(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAvailableRolesGetParams) -> Result<models::AvailableRolesResponse, Error<ObjectAccountsObjectIdAvailableRolesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/available-roles", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdAvailableRolesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdPutParams) -> Result<models::Account, Error<ObjectAccountsObjectIdPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let account_update = params.account_update;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&account_update);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_role_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdRoleDeleteParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdRoleDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let delete_role = params.delete_role;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/role", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&delete_role);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdRoleDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_role_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdRolePutParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdRolePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let update_role = params.update_role;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/role", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_role);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdRolePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_accounts_object_id_role_report_get(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdRoleReportGetParams) -> Result<models::AccountRolesReport, Error<ObjectAccountsObjectIdRoleReportGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/accounts/{objectId}/role/report", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAccountsObjectIdRoleReportGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_announcements_object_id_claim_post(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdClaimPostParams) -> Result<models::CommonResponse, Error<ObjectAnnouncementsObjectIdClaimPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let announcement_request = params.announcement_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/announcements/{objectId}/claim", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&announcement_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAnnouncementsObjectIdClaimPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_announcements_object_id_delete(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdDeleteParams) -> Result<models::CommonResponse, Error<ObjectAnnouncementsObjectIdDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let announcement_request = params.announcement_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/announcements/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&announcement_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAnnouncementsObjectIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_announcements_object_id_get(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdGetParams) -> Result<models::AnnouncementQueryResponse, Error<ObjectAnnouncementsObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let include_deleted = params.include_deleted;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/announcements/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_deleted {
        local_var_req_builder = local_var_req_builder.query(&[("include_deleted", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAnnouncementsObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_announcements_object_id_raw_get(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdRawGetParams) -> Result<models::AnnouncementRawResponse, Error<ObjectAnnouncementsObjectIdRawGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/announcements/{objectId}/raw", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAnnouncementsObjectIdRawGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_announcements_object_id_read_put(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdReadPutParams) -> Result<models::CommonResponse, Error<ObjectAnnouncementsObjectIdReadPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let announcement_request = params.announcement_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/announcements/{objectId}/read", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&announcement_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectAnnouncementsObjectIdReadPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_calendars_object_id_claim_post(configuration: &configuration::Configuration, params: ObjectCalendarsObjectIdClaimPostParams) -> Result<models::CommonResponse, Error<ObjectCalendarsObjectIdClaimPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let calendar_claim_request = params.calendar_claim_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/calendars/{objectId}/claim", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&calendar_claim_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCalendarsObjectIdClaimPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_calendars_object_id_get(configuration: &configuration::Configuration, params: ObjectCalendarsObjectIdGetParams) -> Result<models::CalendarQueryResponse, Error<ObjectCalendarsObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/calendars/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCalendarsObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_chat_v2_object_id_get(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdGetParams) -> Result<models::GetRoomsResponse, Error<ObjectChatV2ObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let scope = params.scope;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/chatV2/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectChatV2ObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_chat_v2_object_id_messages_post(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdMessagesPostParams) -> Result<models::SendMessageResponse, Error<ObjectChatV2ObjectIdMessagesPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let send_message_request = params.send_message_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/chatV2/{objectId}/messages", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&send_message_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectChatV2ObjectIdMessagesPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_chat_v2_object_id_rooms_delete(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdRoomsDeleteParams) -> Result<models::LeaveRoomResponse, Error<ObjectChatV2ObjectIdRoomsDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let leave_room_request = params.leave_room_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/chatV2/{objectId}/rooms", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&leave_room_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectChatV2ObjectIdRoomsDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_chat_v2_object_id_rooms_get(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdRoomsGetParams) -> Result<models::GetRoomsResponse, Error<ObjectChatV2ObjectIdRoomsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/chatV2/{objectId}/rooms", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectChatV2ObjectIdRoomsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_chat_v2_object_id_rooms_post(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdRoomsPostParams) -> Result<models::CreateRoomResponse, Error<ObjectChatV2ObjectIdRoomsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_room_request = params.create_room_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/chatV2/{objectId}/rooms", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_room_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectChatV2ObjectIdRoomsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_coupons_count_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdCouponsCountGetParams) -> Result<models::GetTotalCouponResponse, Error<ObjectCommerceObjectIdCouponsCountGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/coupons/count", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdCouponsCountGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_coupons_post(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdCouponsPostParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdCouponsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let give_coupon_req = params.give_coupon_req;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/coupons", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&give_coupon_req);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdCouponsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdGetParams) -> Result<models::GetActiveOffersResponse, Error<ObjectCommerceObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let scope = params.scope;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_listings_cooldown_put(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdListingsCooldownPutParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdListingsCooldownPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let cooldown_modifier_request = params.cooldown_modifier_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/listings/cooldown", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&cooldown_modifier_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdListingsCooldownPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_listings_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdListingsGetParams) -> Result<models::ActiveListingResponse, Error<ObjectCommerceObjectIdListingsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let listing = params.listing;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let store = params.store;
    let time = params.time;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/listings", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("listing", &listing.to_string())]);
    if let Some(ref local_var_str) = store {
        local_var_req_builder = local_var_req_builder.query(&[("store", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time {
        local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdListingsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_offers_admin_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdOffersAdminGetParams) -> Result<models::GetActiveOffersResponse, Error<ObjectCommerceObjectIdOffersAdminGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let language = params.language;
    let time = params.time;
    let stores = params.stores;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/offersAdmin", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time {
        local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stores {
        local_var_req_builder = local_var_req_builder.query(&[("stores", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdOffersAdminGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_offers_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdOffersGetParams) -> Result<models::GetActiveOffersResponse, Error<ObjectCommerceObjectIdOffersGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let language = params.language;
    let time = params.time;
    let stores = params.stores;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/offers", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = language {
        local_var_req_builder = local_var_req_builder.query(&[("language", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time {
        local_var_req_builder = local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = stores {
        local_var_req_builder = local_var_req_builder.query(&[("stores", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdOffersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_purchase_post(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdPurchasePostParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdPurchasePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let purchase_request = params.purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/purchase", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdPurchasePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_purchase_put(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdPurchasePutParams) -> Result<models::ResultResponse, Error<ObjectCommerceObjectIdPurchasePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let report_purchase_request = params.report_purchase_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/purchase", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&report_purchase_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdPurchasePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_stats_update_post(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdStatsUpdatePostParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdStatsUpdatePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stat_subscription_notification = params.stat_subscription_notification;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/stats/update", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stat_subscription_notification);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdStatsUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_commerce_object_id_status_delete(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdStatusDeleteParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdStatusDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let clear_status_request = params.clear_status_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/commerce/{objectId}/status", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&clear_status_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectCommerceObjectIdStatusDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_event_players_object_id_claim_post(configuration: &configuration::Configuration, params: ObjectEventPlayersObjectIdClaimPostParams) -> Result<models::EventClaimResponse, Error<ObjectEventPlayersObjectIdClaimPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let event_claim_request = params.event_claim_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/event-players/{objectId}/claim", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&event_claim_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventPlayersObjectIdClaimPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_event_players_object_id_get(configuration: &configuration::Configuration, params: ObjectEventPlayersObjectIdGetParams) -> Result<models::EventPlayerView, Error<ObjectEventPlayersObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/event-players/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventPlayersObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_event_players_object_id_score_put(configuration: &configuration::Configuration, params: ObjectEventPlayersObjectIdScorePutParams) -> Result<models::CommonResponse, Error<ObjectEventPlayersObjectIdScorePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let event_score_request = params.event_score_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/event-players/{objectId}/score", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&event_score_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventPlayersObjectIdScorePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_events_object_id_content_delete(configuration: &configuration::Configuration, params: ObjectEventsObjectIdContentDeleteParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdContentDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/events/{objectId}/content", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventsObjectIdContentDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_events_object_id_content_put(configuration: &configuration::Configuration, params: ObjectEventsObjectIdContentPutParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdContentPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let set_content_request = params.set_content_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/events/{objectId}/content", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&set_content_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventsObjectIdContentPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_events_object_id_end_phase_put(configuration: &configuration::Configuration, params: ObjectEventsObjectIdEndPhasePutParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdEndPhasePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let event_phase_end_request = params.event_phase_end_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/events/{objectId}/endPhase", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&event_phase_end_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventsObjectIdEndPhasePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_events_object_id_get(configuration: &configuration::Configuration, params: ObjectEventsObjectIdGetParams) -> Result<models::EventObjectData, Error<ObjectEventsObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/events/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventsObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_events_object_id_ping_get(configuration: &configuration::Configuration, params: ObjectEventsObjectIdPingGetParams) -> Result<models::PingRsp, Error<ObjectEventsObjectIdPingGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/events/{objectId}/ping", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventsObjectIdPingGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_events_object_id_refresh_put(configuration: &configuration::Configuration, params: ObjectEventsObjectIdRefreshPutParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdRefreshPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/events/{objectId}/refresh", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectEventsObjectIdRefreshPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_availability_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdAvailabilityGetParams) -> Result<models::AvailabilityResponse, Error<ObjectGroupUsersObjectIdAvailabilityGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let r#type = params.r#type;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let name = params.name;
    let tag = params.tag;
    let sub_group = params.sub_group;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/availability", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = tag {
        local_var_req_builder = local_var_req_builder.query(&[("tag", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    if let Some(ref local_var_str) = sub_group {
        local_var_req_builder = local_var_req_builder.query(&[("subGroup", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdAvailabilityGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdGetParams) -> Result<models::GroupUser, Error<ObjectGroupUsersObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_group_post(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdGroupPostParams) -> Result<models::GroupCreateResponse, Error<ObjectGroupUsersObjectIdGroupPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_create = params.group_create;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/group", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_create);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdGroupPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_join_delete(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdJoinDeleteParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupUsersObjectIdJoinDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_membership_request = params.group_membership_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/join", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_membership_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdJoinDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_join_post(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdJoinPostParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupUsersObjectIdJoinPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_membership_request = params.group_membership_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/join", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_membership_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdJoinPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_recommended_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdRecommendedGetParams) -> Result<models::GroupSearchResponse, Error<ObjectGroupUsersObjectIdRecommendedGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/recommended", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdRecommendedGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_group_users_object_id_search_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdSearchGetParams) -> Result<models::GroupSearchResponse, Error<ObjectGroupUsersObjectIdSearchGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let r#type = params.r#type;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let name = params.name;
    let score_min = params.score_min;
    let sort_field = params.sort_field;
    let user_score = params.user_score;
    let has_slots = params.has_slots;
    let enrollment_types = params.enrollment_types;
    let offset = params.offset;
    let score_max = params.score_max;
    let sub_group = params.sub_group;
    let sort_value = params.sort_value;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/group-users/{objectId}/search", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = name {
        local_var_req_builder = local_var_req_builder.query(&[("name", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = score_min {
        local_var_req_builder = local_var_req_builder.query(&[("scoreMin", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_field {
        local_var_req_builder = local_var_req_builder.query(&[("sortField", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = user_score {
        local_var_req_builder = local_var_req_builder.query(&[("userScore", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = has_slots {
        local_var_req_builder = local_var_req_builder.query(&[("hasSlots", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = enrollment_types {
        local_var_req_builder = local_var_req_builder.query(&[("enrollmentTypes", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = score_max {
        local_var_req_builder = local_var_req_builder.query(&[("scoreMax", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sub_group {
        local_var_req_builder = local_var_req_builder.query(&[("subGroup", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_value {
        local_var_req_builder = local_var_req_builder.query(&[("sortValue", &local_var_str.to_string())]);
    }
    local_var_req_builder = local_var_req_builder.query(&[("type", &r#type.to_string())]);
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupUsersObjectIdSearchGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_apply_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdApplyPostParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdApplyPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_application = params.group_application;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/apply", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_application);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdApplyPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_delete(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDeleteParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let disband_request = params.disband_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&disband_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_donations_claim_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDonationsClaimPutParams) -> Result<models::EmptyResponse, Error<ObjectGroupsObjectIdDonationsClaimPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/donations/claim", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdDonationsClaimPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_donations_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDonationsPostParams) -> Result<models::EmptyResponse, Error<ObjectGroupsObjectIdDonationsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let create_donation_request = params.create_donation_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/donations", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_donation_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdDonationsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_donations_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDonationsPutParams) -> Result<models::EmptyResponse, Error<ObjectGroupsObjectIdDonationsPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let make_donation_request = params.make_donation_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/donations", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&make_donation_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdDonationsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_get(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdGetParams) -> Result<models::Group, Error<ObjectGroupsObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_invite_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdInvitePostParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdInvitePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_invite = params.group_invite;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/invite", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_invite);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdInvitePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_kick_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdKickPostParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupsObjectIdKickPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let kick_request = params.kick_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/kick", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&kick_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdKickPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_member_delete(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdMemberDeleteParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupsObjectIdMemberDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let kick_request = params.kick_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/member", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&kick_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdMemberDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_petition_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdPetitionPostParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdPetitionPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_application = params.group_application;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/petition", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_application);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdPetitionPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdPutParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let group_update = params.group_update;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&group_update);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_groups_object_id_role_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdRolePutParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdRolePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let role_change_request = params.role_change_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/groups/{objectId}/role", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&role_change_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectGroupsObjectIdRolePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_get(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdGetParams) -> Result<models::InventoryView, Error<ObjectInventoryObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let scope = params.scope;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = scope {
        local_var_req_builder = local_var_req_builder.query(&[("scope", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_multipliers_get(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdMultipliersGetParams) -> Result<models::MultipliersGetResponse, Error<ObjectInventoryObjectIdMultipliersGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/multipliers", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdMultipliersGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_post(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdPostParams) -> Result<models::InventoryView, Error<ObjectInventoryObjectIdPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let inventory_query_request = params.inventory_query_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inventory_query_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_preview_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdPreviewPutParams) -> Result<models::PreviewVipBonusResponse, Error<ObjectInventoryObjectIdPreviewPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let inventory_update_request = params.inventory_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/preview", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inventory_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdPreviewPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_proxy_reload_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdProxyReloadPutParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdProxyReloadPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/proxy/reload", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdProxyReloadPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdPutParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let inventory_update_request = params.inventory_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&inventory_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_transaction_delete(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdTransactionDeleteParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdTransactionDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let end_transaction_request = params.end_transaction_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/transaction", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&end_transaction_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdTransactionDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_inventory_object_id_transfer_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdTransferPutParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdTransferPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let transfer_request = params.transfer_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/inventory/{objectId}/transfer", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&transfer_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectInventoryObjectIdTransferPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_assignment_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdAssignmentDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdAssignmentDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let leaderboard_remove_cache_entry_request = params.leaderboard_remove_cache_entry_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/assignment", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&leaderboard_remove_cache_entry_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdAssignmentDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_assignment_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdAssignmentGetParams) -> Result<models::LeaderboardAssignmentInfo, Error<ObjectLeaderboardsObjectIdAssignmentGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/assignment", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdAssignmentGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_details_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdDetailsGetParams) -> Result<models::LeaderboardDetails, Error<ObjectLeaderboardsObjectIdDetailsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let from = params.from;
    let max = params.max;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/details", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdDetailsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_entries_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdEntriesDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdEntriesDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/entries", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdEntriesDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_entry_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdEntryDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdEntryDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let leaderboard_remove_entry_request = params.leaderboard_remove_entry_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/entry", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&leaderboard_remove_entry_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdEntryDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_entry_put(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdEntryPutParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdEntryPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let leaderboard_add_request = params.leaderboard_add_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/entry", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&leaderboard_add_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdEntryPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_freeze_put(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdFreezePutParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdFreezePutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/freeze", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdFreezePutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_friends_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdFriendsGetParams) -> Result<models::LeaderBoardViewResponse, Error<ObjectLeaderboardsObjectIdFriendsGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/friends", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdFriendsGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_matches_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdMatchesGetParams) -> Result<models::MatchMakingMatchesPvpResponse, Error<ObjectLeaderboardsObjectIdMatchesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let pool_size = params.pool_size;
    let windows = params.windows;
    let window_size = params.window_size;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/matches", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("poolSize", &pool_size.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("windows", &windows.to_string())]);
    local_var_req_builder = local_var_req_builder.query(&[("windowSize", &window_size.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdMatchesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_membership_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdMembershipGetParams) -> Result<models::LeaderboardMembershipResponse, Error<ObjectLeaderboardsObjectIdMembershipGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let player_id = params.player_id;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/membership", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("playerId", &player_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdMembershipGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_partition_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdPartitionGetParams) -> Result<models::LeaderboardPartitionInfo, Error<ObjectLeaderboardsObjectIdPartitionGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let player_id = params.player_id;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/partition", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("playerId", &player_id.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdPartitionGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_post(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdPostParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let leaderboard_create_request = params.leaderboard_create_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&leaderboard_create_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_ranks_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdRanksGetParams) -> Result<models::LeaderBoardViewResponse, Error<ObjectLeaderboardsObjectIdRanksGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let ids = params.ids;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/ranks", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("ids", &ids.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdRanksGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_swap_put(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdSwapPutParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdSwapPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let leaderboard_swap_request = params.leaderboard_swap_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/swap", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&leaderboard_swap_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdSwapPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_leaderboards_object_id_view_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdViewGetParams) -> Result<models::LeaderBoardViewResponse, Error<ObjectLeaderboardsObjectIdViewGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let max = params.max;
    let focus = params.focus;
    let friends = params.friends;
    let from = params.from;
    let outlier = params.outlier;
    let guild = params.guild;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/leaderboards/{objectId}/view", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = max {
        local_var_req_builder = local_var_req_builder.query(&[("max", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = focus {
        local_var_req_builder = local_var_req_builder.query(&[("focus", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = friends {
        local_var_req_builder = local_var_req_builder.query(&[("friends", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = from {
        local_var_req_builder = local_var_req_builder.query(&[("from", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = outlier {
        local_var_req_builder = local_var_req_builder.query(&[("outlier", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = guild {
        local_var_req_builder = local_var_req_builder.query(&[("guild", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectLeaderboardsObjectIdViewGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_accept_many_put(configuration: &configuration::Configuration, params: ObjectMailObjectIdAcceptManyPutParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdAcceptManyPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let accept_multiple_attachments = params.accept_multiple_attachments;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/accept/many", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&accept_multiple_attachments);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdAcceptManyPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_bulk_post(configuration: &configuration::Configuration, params: ObjectMailObjectIdBulkPostParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdBulkPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let bulk_send_mail_request = params.bulk_send_mail_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/bulk", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&bulk_send_mail_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdBulkPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_bulk_put(configuration: &configuration::Configuration, params: ObjectMailObjectIdBulkPutParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdBulkPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let bulk_update_mail_object_request = params.bulk_update_mail_object_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/bulk", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&bulk_update_mail_object_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdBulkPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_categories_get(configuration: &configuration::Configuration, params: ObjectMailObjectIdCategoriesGetParams) -> Result<models::ListMailCategoriesResponse, Error<ObjectMailObjectIdCategoriesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/categories", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdCategoriesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_detail_get(configuration: &configuration::Configuration, params: ObjectMailObjectIdDetailGetParams) -> Result<models::MailResponse, Error<ObjectMailObjectIdDetailGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let mid = params.mid;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/detail", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("mid", &mid.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdDetailGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_get(configuration: &configuration::Configuration, params: ObjectMailObjectIdGetParams) -> Result<models::MailQueryResponse, Error<ObjectMailObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_post(configuration: &configuration::Configuration, params: ObjectMailObjectIdPostParams) -> Result<models::SendMailResponse, Error<ObjectMailObjectIdPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let send_mail_object_request = params.send_mail_object_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&send_mail_object_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_put(configuration: &configuration::Configuration, params: ObjectMailObjectIdPutParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let update_mail_request = params.update_mail_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_mail_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_mail_object_id_search_post(configuration: &configuration::Configuration, params: ObjectMailObjectIdSearchPostParams) -> Result<models::MailSearchResponse, Error<ObjectMailObjectIdSearchPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let mail_search_request = params.mail_search_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/mail/{objectId}/search", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&mail_search_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectMailObjectIdSearchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_stats_object_id_client_get(configuration: &configuration::Configuration, params: ObjectStatsObjectIdClientGetParams) -> Result<models::StatsResponse, Error<ObjectStatsObjectIdClientGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stats = params.stats;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/stats/{objectId}/client", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = stats {
        local_var_req_builder = local_var_req_builder.query(&[("stats", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectStatsObjectIdClientGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_stats_object_id_client_post(configuration: &configuration::Configuration, params: ObjectStatsObjectIdClientPostParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdClientPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stat_update_request = params.stat_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/stats/{objectId}/client", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stat_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectStatsObjectIdClientPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_stats_object_id_client_stringlist_post(configuration: &configuration::Configuration, params: ObjectStatsObjectIdClientStringlistPostParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdClientStringlistPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stat_update_request_string_list_format = params.stat_update_request_string_list_format;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/stats/{objectId}/client/stringlist", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stat_update_request_string_list_format);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectStatsObjectIdClientStringlistPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_stats_object_id_delete(configuration: &configuration::Configuration, params: ObjectStatsObjectIdDeleteParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stat_request = params.stat_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/stats/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stat_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectStatsObjectIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_stats_object_id_get(configuration: &configuration::Configuration, params: ObjectStatsObjectIdGetParams) -> Result<models::StatsResponse, Error<ObjectStatsObjectIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stats = params.stats;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/stats/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = stats {
        local_var_req_builder = local_var_req_builder.query(&[("stats", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectStatsObjectIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn object_stats_object_id_post(configuration: &configuration::Configuration, params: ObjectStatsObjectIdPostParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let x_beam_scope = params.x_beam_scope;
    let object_id = params.object_id;
    let x_beam_gamertag = params.x_beam_gamertag;
    let stat_update_request = params.stat_update_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/object/stats/{objectId}/", local_var_configuration.base_path, objectId=crate::apis::urlencode(object_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.header("X-BEAM-SCOPE", x_beam_scope.to_string());
    if let Some(local_var_param_value) = x_beam_gamertag {
        local_var_req_builder = local_var_req_builder.header("X-BEAM-GAMERTAG", local_var_param_value.to_string());
    }
    if let Some(ref local_var_apikey) = local_var_configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("X-DE-SIGNATURE", local_var_value);
    };
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&stat_update_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ObjectStatsObjectIdPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

