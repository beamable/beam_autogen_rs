/*
 * Beamable API
 *
 * Autogenerated Beamable API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@beamable.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`basic_accounts_admin_admin_user_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAdminAdminUserPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_elevated_account_request: Option<models::CreateElevatedAccountRequest>
}

/// struct for passing parameters to the method [`basic_accounts_admin_admin_users_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAdminAdminUsersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_admin_me_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAdminMeGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_device_id_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableDeviceIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub device_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_external_identity_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableExternalIdentityGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub provider_service: String,
    pub user_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub provider_namespace: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub email: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_available_third_party_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsAvailableThirdPartyGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub third_party: String,
    pub token: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_email_update_confirm_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsEmailUpdateConfirmPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub email_update_confirmation: Option<models::EmailUpdateConfirmation>
}

/// struct for passing parameters to the method [`basic_accounts_email_update_init_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsEmailUpdateInitPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub email_update_request: Option<models::EmailUpdateRequest>
}

/// struct for passing parameters to the method [`basic_accounts_external_identity_delete`]
#[derive(Clone, Debug)]
pub struct BasicAccountsExternalIdentityDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_external_identity_api_request: Option<models::DeleteExternalIdentityApiRequest>
}

/// struct for passing parameters to the method [`basic_accounts_external_identity_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsExternalIdentityPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub attach_external_identity_api_request: Option<models::AttachExternalIdentityApiRequest>
}

/// struct for passing parameters to the method [`basic_accounts_find_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsFindGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub query: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_get_personally_identifiable_information_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsGetPersonallyIdentifiableInformationGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub query: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_me_device_delete`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMeDeviceDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_devices_request: Option<models::DeleteDevicesRequest>
}

/// struct for passing parameters to the method [`basic_accounts_me_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMeGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_accounts_me_put`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub account_update: Option<models::AccountUpdate>
}

/// struct for passing parameters to the method [`basic_accounts_me_third_party_delete`]
#[derive(Clone, Debug)]
pub struct BasicAccountsMeThirdPartyDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub third_party_available_request: Option<models::ThirdPartyAvailableRequest>
}

/// struct for passing parameters to the method [`basic_accounts_password_update_confirm_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsPasswordUpdateConfirmPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub password_update_confirmation: Option<models::PasswordUpdateConfirmation>
}

/// struct for passing parameters to the method [`basic_accounts_password_update_init_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsPasswordUpdateInitPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub password_update_request: Option<models::PasswordUpdateRequest>
}

/// struct for passing parameters to the method [`basic_accounts_register_post`]
#[derive(Clone, Debug)]
pub struct BasicAccountsRegisterPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub account_registration: Option<models::AccountRegistration>
}

/// struct for passing parameters to the method [`basic_accounts_search_get`]
#[derive(Clone, Debug)]
pub struct BasicAccountsSearchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub query: String,
    pub page: i32,
    pub pagesize: i32,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_content_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsContentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_delete`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_announcement_request: Option<models::DeleteAnnouncementRequest>
}

/// struct for passing parameters to the method [`basic_announcements_list_definitions_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsListDefinitionsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_list_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsListGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_list_tags_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsListTagsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tag_name_filter: Option<String>
}

/// struct for passing parameters to the method [`basic_announcements_post`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_dto: Option<models::AnnouncementDto>
}

/// struct for passing parameters to the method [`basic_announcements_search_get`]
#[derive(Clone, Debug)]
pub struct BasicAnnouncementsSearchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub date: Option<String>
}

/// struct for passing parameters to the method [`basic_auth_token_get`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub token: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_auth_token_list_get`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenListGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub page_size: i32,
    pub page: i32,
    pub gamer_tag_or_account_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cid: Option<i64>,
    pub pid: Option<String>
}

/// struct for passing parameters to the method [`basic_auth_token_post`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub token_request_wrapper: Option<models::TokenRequestWrapper>
}

/// struct for passing parameters to the method [`basic_auth_token_revoke_put`]
#[derive(Clone, Debug)]
pub struct BasicAuthTokenRevokePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub revoke_token_request: Option<models::RevokeTokenRequest>
}

/// struct for passing parameters to the method [`basic_beamo_image_commit_put`]
#[derive(Clone, Debug)]
pub struct BasicBeamoImageCommitPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub commit_image_request: Option<models::CommitImageRequest>
}

/// struct for passing parameters to the method [`basic_beamo_image_urls_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoImageUrlsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_service_urls_request: Option<models::GetServiceUrlsRequest>
}

/// struct for passing parameters to the method [`basic_beamo_logs_url_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoLogsUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_logs_url_request: Option<models::GetLogsUrlRequest>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_current_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestCurrentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archived: Option<bool>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_deploy_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestDeployPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archived: Option<bool>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub beamo_basic_post_manifest_request: Option<models::BeamoBasicPostManifestRequest>
}

/// struct for passing parameters to the method [`basic_beamo_manifest_pull_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestPullPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pull_beamo_manifest_request: Option<models::PullBeamoManifestRequest>
}

/// struct for passing parameters to the method [`basic_beamo_manifests_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoManifestsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub offset: Option<i32>,
    pub limit: Option<i32>,
    pub archived: Option<bool>
}

/// struct for passing parameters to the method [`basic_beamo_metrics_url_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMetricsUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_metrics_url_request: Option<models::GetMetricsUrlRequest>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_federation_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceFederationPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registrations_query: Option<models::MicroserviceRegistrationsQuery>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_federation_traffic_delete`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceFederationTrafficDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registration_request: Option<models::MicroserviceRegistrationRequest>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_federation_traffic_put`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceFederationTrafficPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registration_request: Option<models::MicroserviceRegistrationRequest>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_registrations_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceRegistrationsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub microservice_registrations_query: Option<models::MicroserviceRegistrationsQuery>
}

/// struct for passing parameters to the method [`basic_beamo_microservice_secret_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoMicroserviceSecretGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_query_logs_delete`]
#[derive(Clone, Debug)]
pub struct BasicBeamoQueryLogsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub query: Option<models::Query>
}

/// struct for passing parameters to the method [`basic_beamo_query_logs_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoQueryLogsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_logs_insight_url_request: Option<models::GetLogsInsightUrlRequest>
}

/// struct for passing parameters to the method [`basic_beamo_query_logs_result_post`]
#[derive(Clone, Debug)]
pub struct BasicBeamoQueryLogsResultPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub query: Option<models::Query>
}

/// struct for passing parameters to the method [`basic_beamo_registry_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoRegistryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_status_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoStatusGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_storage_connection_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoStorageConnectionGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_storage_performance_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoStoragePerformanceGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub storage_object_name: String,
    pub granularity: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub end_date: Option<String>,
    pub start_date: Option<String>,
    pub period: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_templates_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoTemplatesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_beamo_upload_api_get`]
#[derive(Clone, Debug)]
pub struct BasicBeamoUploadApiGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_commit_manifest_put`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataCommitManifestPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_requests: Option<models::UploadRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_delete`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub object_requests: Option<models::ObjectRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_download_url_from_portal_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataDownloadUrlFromPortalPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub object_requests: Option<models::ObjectRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_download_url_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataDownloadUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub object_requests: Option<models::ObjectRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_move_from_portal_put`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataMoveFromPortalPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_basic_cloud_data_request: Option<models::PlayerBasicCloudDataRequest>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_move_put`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataMovePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_basic_cloud_data_request: Option<models::PlayerBasicCloudDataRequest>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_replace_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataReplacePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub replace_objects_request: Option<models::ReplaceObjectsRequest>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_upload_url_from_portal_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataUploadUrlFromPortalPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_requests_from_portal: Option<models::UploadRequestsFromPortal>
}

/// struct for passing parameters to the method [`basic_cloudsaving_data_upload_url_post`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingDataUploadUrlPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_requests: Option<models::UploadRequests>
}

/// struct for passing parameters to the method [`basic_cloudsaving_get`]
#[derive(Clone, Debug)]
pub struct BasicCloudsavingGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id: Option<i64>
}

/// struct for passing parameters to the method [`basic_commerce_catalog_get`]
#[derive(Clone, Debug)]
pub struct BasicCommerceCatalogGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub version: Option<i64>
}

/// struct for passing parameters to the method [`basic_commerce_catalog_legacy_post`]
#[derive(Clone, Debug)]
pub struct BasicCommerceCatalogLegacyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_catalog_request: Option<models::SaveCatalogRequest>
}

/// struct for passing parameters to the method [`basic_commerce_skus_get`]
#[derive(Clone, Debug)]
pub struct BasicCommerceSkusGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub version: Option<i64>
}

/// struct for passing parameters to the method [`basic_commerce_skus_post`]
#[derive(Clone, Debug)]
pub struct BasicCommerceSkusPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_skus_request: Option<models::SaveSkusRequest>
}

/// struct for passing parameters to the method [`basic_content_binary_post`]
#[derive(Clone, Debug)]
pub struct BasicContentBinaryPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_binary_request: Option<models::SaveBinaryRequest>
}

/// struct for passing parameters to the method [`basic_content_content_get`]
#[derive(Clone, Debug)]
pub struct BasicContentContentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub content_id: String,
    pub version: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_localizations_delete`]
#[derive(Clone, Debug)]
pub struct BasicContentLocalizationsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_localization_request: Option<models::DeleteLocalizationRequest>
}

/// struct for passing parameters to the method [`basic_content_localizations_get`]
#[derive(Clone, Debug)]
pub struct BasicContentLocalizationsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_localizations_put`]
#[derive(Clone, Debug)]
pub struct BasicContentLocalizationsPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub put_localizations_request: Option<models::PutLocalizationsRequest>
}

/// struct for passing parameters to the method [`basic_content_manifest_checksum_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestChecksumGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>,
    /// UID of the content manifest
    pub uid: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_checksums_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestChecksumsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_exact_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestExactGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub uid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>,
    /// UID of the content manifest
    pub uid: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_history_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestHistoryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub id: Option<String>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`basic_content_manifest_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_manifest_request: Option<models::SaveManifestRequest>
}

/// struct for passing parameters to the method [`basic_content_manifest_private_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPrivateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>,
    /// UID of the content manifest
    pub uid: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_private_json_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPrivateJsonGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// Content ID of the content manifest
    pub id: Option<String>,
    /// UID of the content manifest
    pub uid: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_public_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPublicGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// ID of the content manifest
    pub id: Option<String>,
    /// UID of the content manifest
    pub uid: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_public_json_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPublicJsonGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    /// Content ID of the content manifest
    pub id: Option<String>,
    /// UID of the content manifest
    pub uid: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifest_pull_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestPullPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pull_manifest_request: Option<models::PullManifestRequest>
}

/// struct for passing parameters to the method [`basic_content_manifest_repeat_put`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestRepeatPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub repeat_manifest_request: Option<models::RepeatManifestRequest>
}

/// struct for passing parameters to the method [`basic_content_manifests_archive_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsArchivePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archive_or_unarchive_manifests_request: Option<models::ArchiveOrUnarchiveManifestsRequest>
}

/// struct for passing parameters to the method [`basic_content_manifests_get`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_content_manifests_pull_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsPullPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pull_all_manifests_request: Option<models::PullAllManifestsRequest>
}

/// struct for passing parameters to the method [`basic_content_manifests_unarchive_post`]
#[derive(Clone, Debug)]
pub struct BasicContentManifestsUnarchivePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archive_or_unarchive_manifests_request: Option<models::ArchiveOrUnarchiveManifestsRequest>
}

/// struct for passing parameters to the method [`basic_content_post`]
#[derive(Clone, Debug)]
pub struct BasicContentPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_content_request: Option<models::SaveContentRequest>
}

/// struct for passing parameters to the method [`basic_content_text_post`]
#[derive(Clone, Debug)]
pub struct BasicContentTextPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub save_text_request: Option<models::SaveTextRequest>
}

/// struct for passing parameters to the method [`basic_events_apply_content_post`]
#[derive(Clone, Debug)]
pub struct BasicEventsApplyContentPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_apply_request: Option<models::EventApplyRequest>
}

/// struct for passing parameters to the method [`basic_events_calendar_get`]
#[derive(Clone, Debug)]
pub struct BasicEventsCalendarGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub from: Option<String>,
    pub to: Option<String>,
    pub query: Option<String>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`basic_events_content_get`]
#[derive(Clone, Debug)]
pub struct BasicEventsContentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_events_running_get`]
#[derive(Clone, Debug)]
pub struct BasicEventsRunningGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_inventory_currency_get`]
#[derive(Clone, Debug)]
pub struct BasicInventoryCurrencyGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_inventory_items_get`]
#[derive(Clone, Debug)]
pub struct BasicInventoryItemsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_leaderboards_assignment_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsAssignmentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub board_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub join_board: Option<bool>
}

/// struct for passing parameters to the method [`basic_leaderboards_list_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsListGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub skip: Option<i32>,
    pub limit: Option<i32>,
    pub prefix: Option<String>,
    pub include_partitions: Option<bool>
}

/// struct for passing parameters to the method [`basic_leaderboards_player_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsPlayerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub dbid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_leaderboards_uid_get`]
#[derive(Clone, Debug)]
pub struct BasicLeaderboardsUidGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_mail_attachments_put`]
#[derive(Clone, Debug)]
pub struct BasicMailAttachmentsPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub accept_multiple_attachments: Option<models::AcceptMultipleAttachments>
}

/// struct for passing parameters to the method [`basic_mail_bulk_post`]
#[derive(Clone, Debug)]
pub struct BasicMailBulkPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub bulk_send_mail_request: Option<models::BulkSendMailRequest>
}

/// struct for passing parameters to the method [`basic_mail_get`]
#[derive(Clone, Debug)]
pub struct BasicMailGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub mid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_mail_put`]
#[derive(Clone, Debug)]
pub struct BasicMailPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_mail_request: Option<models::UpdateMailRequest>
}

/// struct for passing parameters to the method [`basic_mail_template_get`]
#[derive(Clone, Debug)]
pub struct BasicMailTemplateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub template_name: String,
    pub gamer_tag: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_notification_channel_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationChannelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_custom_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationCustomPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_game_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationGamePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_generic_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationGenericPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_get`]
#[derive(Clone, Debug)]
pub struct BasicNotificationGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_notification_player_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationPlayerPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub notification_request: Option<models::NotificationRequest>
}

/// struct for passing parameters to the method [`basic_notification_server_post`]
#[derive(Clone, Debug)]
pub struct BasicNotificationServerPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub server_event: Option<models::ServerEvent>
}

/// struct for passing parameters to the method [`basic_payments_audits_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsAuditsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub providerid: Option<String>,
    pub provider: Option<String>,
    pub state: Option<String>,
    pub txid: Option<i64>,
    pub player: Option<i64>,
    pub start: Option<i32>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`basic_payments_coupon_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_coupon_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsCouponPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_facebook_update_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookUpdateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub hub_mode: String,
    pub hub_challenge: String,
    pub hub_verify_token: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_facebook_update_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsFacebookUpdatePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub facebook_payment_update_request: Option<models::FacebookPaymentUpdateRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_googleplay_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsGoogleplayPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_itunes_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsItunesPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_auth_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamAuthPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub steam_auth_request: Option<models::SteamAuthRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_order_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamOrderGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub order_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_prices_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPricesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub steam_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_products_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamProductsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub steam_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_steam_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsSteamPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_test_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsTestPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_product_get`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsProductGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub sku: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_begin_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseBeginPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub begin_purchase_request: Option<models::BeginPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_cancel_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseCancelPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cancel_purchase_request: Option<models::CancelPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_complete_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseCompletePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub complete_purchase_request: Option<models::CompletePurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_fail_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseFailPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub fail_purchase_request: Option<models::FailPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_track_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseTrackPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub track_purchase_request: Option<models::TrackPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_payments_windows_purchase_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicPaymentsWindowsPurchaseVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub verify_purchase_request: Option<models::VerifyPurchaseRequest>
}

/// struct for passing parameters to the method [`basic_push_register_post`]
#[derive(Clone, Debug)]
pub struct BasicPushRegisterPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub register_req: Option<models::RegisterReq>
}

/// struct for passing parameters to the method [`basic_push_send_post`]
#[derive(Clone, Debug)]
pub struct BasicPushSendPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_req: Option<models::SendReq>
}

/// struct for passing parameters to the method [`basic_realms_admin_customer_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsAdminCustomerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_admin_inflight_failures_delete`]
#[derive(Clone, Debug)]
pub struct BasicRealmsAdminInflightFailuresDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub batch_delete_in_flight_request: Option<models::BatchDeleteInFlightRequest>
}

/// struct for passing parameters to the method [`basic_realms_admin_inflight_failures_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsAdminInflightFailuresGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub service_name: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub service_object_id: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_client_defaults_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsClientDefaultsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_config_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsConfigGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_config_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsConfigPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub realm_config_change_request: Option<models::RealmConfigChangeRequest>
}

/// struct for passing parameters to the method [`basic_realms_config_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsConfigPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub realm_config_save_request: Option<models::RealmConfigSaveRequest>
}

/// struct for passing parameters to the method [`basic_realms_customer_activate_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerActivateGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub token: String,
    pub cid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_customer_alias_available_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerAliasAvailableGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub alias: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_customer_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_customer_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub new_customer_request: Option<models::NewCustomerRequest>
}

/// struct for passing parameters to the method [`basic_realms_customer_verify_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomerVerifyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub new_customer_request: Option<models::NewCustomerRequest>
}

/// struct for passing parameters to the method [`basic_realms_customers_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsCustomersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_game_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGameGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub root_pid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_game_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGamePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub new_game_request: Option<models::NewGameRequest>
}

/// struct for passing parameters to the method [`basic_realms_game_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGamePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_game_hierarchy_request: Option<models::UpdateGameHierarchyRequest>
}

/// struct for passing parameters to the method [`basic_realms_games_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsGamesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_is_customer_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsIsCustomerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_launch_message_delete`]
#[derive(Clone, Debug)]
pub struct BasicRealmsLaunchMessageDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub remove_launch_message_request: Option<models::RemoveLaunchMessageRequest>
}

/// struct for passing parameters to the method [`basic_realms_launch_message_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsLaunchMessageGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_launch_message_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsLaunchMessagePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_launch_message_request: Option<models::CreateLaunchMessageRequest>
}

/// struct for passing parameters to the method [`basic_realms_plans_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPlansGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_plans_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPlansPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_plan_request: Option<models::CreatePlanRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_beamable_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectBeamablePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_project_request: Option<models::CreateProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_delete`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub archive_project_request: Option<models::ArchiveProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_realms_project_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_project_request: Option<models::CreateProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_promote_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPromoteGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub source_pid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promotions: Option<Vec<String>>,
    pub content_manifest_ids: Option<Vec<String>>
}

/// struct for passing parameters to the method [`basic_realms_project_promote_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPromotePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promote_realm_request: Option<models::PromoteRealmRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub unarchive_project_request: Option<models::UnarchiveProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_project_rename_put`]
#[derive(Clone, Debug)]
pub struct BasicRealmsProjectRenamePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub rename_project_request: Option<models::RenameProjectRequest>
}

/// struct for passing parameters to the method [`basic_realms_promotion_get`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPromotionGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub source_pid: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promotions: Option<Vec<String>>,
    pub content_manifest_ids: Option<Vec<String>>
}

/// struct for passing parameters to the method [`basic_realms_promotion_post`]
#[derive(Clone, Debug)]
pub struct BasicRealmsPromotionPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub promote_realm_request: Option<models::PromoteRealmRequest>
}

/// struct for passing parameters to the method [`basic_session_client_history_get`]
#[derive(Clone, Debug)]
pub struct BasicSessionClientHistoryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub month: Option<i32>,
    pub year: Option<i32>
}

/// struct for passing parameters to the method [`basic_session_heartbeat_post`]
#[derive(Clone, Debug)]
pub struct BasicSessionHeartbeatPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_session_history_get`]
#[derive(Clone, Debug)]
pub struct BasicSessionHistoryGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub dbid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub month: Option<i32>,
    pub year: Option<i32>
}

/// struct for passing parameters to the method [`basic_session_post`]
#[derive(Clone, Debug)]
pub struct BasicSessionPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub start_session_request: Option<models::StartSessionRequest>
}

/// struct for passing parameters to the method [`basic_session_status_get`]
#[derive(Clone, Debug)]
pub struct BasicSessionStatusGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_ids: String,
    pub interval_secs: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_social_blocked_delete`]
#[derive(Clone, Debug)]
pub struct BasicSocialBlockedDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id_request: Option<models::PlayerIdRequest>
}

/// struct for passing parameters to the method [`basic_social_blocked_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialBlockedPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id_request: Option<models::PlayerIdRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_delete`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub player_id_request: Option<models::PlayerIdRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_import_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsImportPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub import_friends_request: Option<models::ImportFriendsRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_invite_delete`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsInviteDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_friend_request: Option<models::SendFriendRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_invite_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsInvitePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_friend_request: Option<models::SendFriendRequest>
}

/// struct for passing parameters to the method [`basic_social_friends_make_post`]
#[derive(Clone, Debug)]
pub struct BasicSocialFriendsMakePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub make_friendship_request: Option<models::MakeFriendshipRequest>
}

/// struct for passing parameters to the method [`basic_social_get`]
#[derive(Clone, Debug)]
pub struct BasicSocialGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_ids: Vec<String>,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_social_my_get`]
#[derive(Clone, Debug)]
pub struct BasicSocialMyGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_stats_batch_post`]
#[derive(Clone, Debug)]
pub struct BasicStatsBatchPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub batch_set_stats_request: Option<models::BatchSetStatsRequest>
}

/// struct for passing parameters to the method [`basic_stats_client_batch_get`]
#[derive(Clone, Debug)]
pub struct BasicStatsClientBatchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub object_ids: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats: Option<String>,
    pub format: Option<String>
}

/// struct for passing parameters to the method [`basic_stats_search_extended_post`]
#[derive(Clone, Debug)]
pub struct BasicStatsSearchExtendedPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub search_extended_request: Option<models::SearchExtendedRequest>
}

/// struct for passing parameters to the method [`basic_stats_search_post`]
#[derive(Clone, Debug)]
pub struct BasicStatsSearchPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats_search_request: Option<models::StatsSearchRequest>
}

/// struct for passing parameters to the method [`basic_stats_subscribe_delete`]
#[derive(Clone, Debug)]
pub struct BasicStatsSubscribeDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats_unsubscribe_request: Option<models::StatsUnsubscribeRequest>
}

/// struct for passing parameters to the method [`basic_stats_subscribe_put`]
#[derive(Clone, Debug)]
pub struct BasicStatsSubscribePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats_subscribe_request: Option<models::StatsSubscribeRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_admin_player_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsAdminPlayerGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tournament_id: Option<String>,
    pub content_id: Option<String>,
    pub has_unclaimed_rewards: Option<bool>
}

/// struct for passing parameters to the method [`basic_tournaments_admin_player_put`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsAdminPlayerPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_player_status_request: Option<models::UpdatePlayerStatusRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_champions_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsChampionsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    pub cycles: i32,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub is_running: Option<bool>,
    pub content_id: Option<String>,
    pub cycle: Option<i32>
}

/// struct for passing parameters to the method [`basic_tournaments_global_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsGlobalGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_groups_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsGroupsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_me_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsMeGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tournament_id: Option<String>,
    pub content_id: Option<String>,
    pub has_unclaimed_rewards: Option<bool>
}

/// struct for passing parameters to the method [`basic_tournaments_me_group_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsMeGroupGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub join_request: Option<models::JoinRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_rewards_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsRewardsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub tournament_id: Option<String>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_rewards_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsRewardsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub rewards_request: Option<models::RewardsRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_score_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsScorePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub score_request: Option<models::ScoreRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_search_groups_post`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsSearchGroupsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub get_status_for_groups_request: Option<models::GetStatusForGroupsRequest>
}

/// struct for passing parameters to the method [`basic_tournaments_standings_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsStandingsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_tournaments_standings_group_get`]
#[derive(Clone, Debug)]
pub struct BasicTournamentsStandingsGroupGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub tournament_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub cycle: Option<i32>,
    pub from: Option<i32>,
    pub content_id: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_admin_data_get`]
#[derive(Clone, Debug)]
pub struct BasicTrialsAdminDataGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub id: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_admin_get`]
#[derive(Clone, Debug)]
pub struct BasicTrialsAdminGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub dbid: i64,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_data_delete`]
#[derive(Clone, Debug)]
pub struct BasicTrialsDataDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_trial_data_request: Option<models::DeleteTrialDataRequest>
}

/// struct for passing parameters to the method [`basic_trials_data_post`]
#[derive(Clone, Debug)]
pub struct BasicTrialsDataPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub upload_trial_data_request: Option<models::UploadTrialDataRequest>
}

/// struct for passing parameters to the method [`basic_trials_delete`]
#[derive(Clone, Debug)]
pub struct BasicTrialsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_trial_request: Option<models::DeleteTrialRequest>
}

/// struct for passing parameters to the method [`basic_trials_get`]
#[derive(Clone, Debug)]
pub struct BasicTrialsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`basic_trials_pause_put`]
#[derive(Clone, Debug)]
pub struct BasicTrialsPausePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub pause_trial_request: Option<models::PauseTrialRequest>
}

/// struct for passing parameters to the method [`basic_trials_post`]
#[derive(Clone, Debug)]
pub struct BasicTrialsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_trial_rest_request: Option<models::CreateTrialRestRequest>
}

/// struct for passing parameters to the method [`basic_trials_schedule_put`]
#[derive(Clone, Debug)]
pub struct BasicTrialsSchedulePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub schedule_trial_request: Option<models::ScheduleTrialRequest>
}

/// struct for passing parameters to the method [`basic_trials_start_put`]
#[derive(Clone, Debug)]
pub struct BasicTrialsStartPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub start_trial_request: Option<models::StartTrialRequest>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_email_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminEmailPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub email_update_request: Option<models::EmailUpdateRequest>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_forget_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminForgetDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_scope_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminScopeDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_role: Option<models::DeleteRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_scope_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminScopePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_role: Option<models::UpdateRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_third_party_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminThirdPartyDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_third_party_association: Option<models::DeleteThirdPartyAssociation>
}

/// struct for passing parameters to the method [`object_accounts_object_id_admin_third_party_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAdminThirdPartyPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub transfer_third_party_association: Option<models::TransferThirdPartyAssociation>
}

/// struct for passing parameters to the method [`object_accounts_object_id_available_roles_get`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdAvailableRolesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_accounts_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub account_update: Option<models::AccountUpdate>
}

/// struct for passing parameters to the method [`object_accounts_object_id_role_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdRoleDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub delete_role: Option<models::DeleteRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_role_put`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdRolePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_role: Option<models::UpdateRole>
}

/// struct for passing parameters to the method [`object_accounts_object_id_role_report_get`]
#[derive(Clone, Debug)]
pub struct ObjectAccountsObjectIdRoleReportGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// AccountId of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_announcements_object_id_claim_post`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdClaimPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_request: Option<models::AnnouncementRequest>
}

/// struct for passing parameters to the method [`object_announcements_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_request: Option<models::AnnouncementRequest>
}

/// struct for passing parameters to the method [`object_announcements_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub include_deleted: Option<bool>
}

/// struct for passing parameters to the method [`object_announcements_object_id_raw_get`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdRawGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_announcements_object_id_read_put`]
#[derive(Clone, Debug)]
pub struct ObjectAnnouncementsObjectIdReadPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub announcement_request: Option<models::AnnouncementRequest>
}

/// struct for passing parameters to the method [`object_calendars_object_id_claim_post`]
#[derive(Clone, Debug)]
pub struct ObjectCalendarsObjectIdClaimPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub calendar_claim_request: Option<models::CalendarClaimRequest>
}

/// struct for passing parameters to the method [`object_calendars_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectCalendarsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub scope: Option<String>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_messages_post`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdMessagesPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_message_request: Option<models::SendMessageRequest>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_rooms_delete`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdRoomsDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leave_room_request: Option<models::LeaveRoomRequest>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_rooms_get`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdRoomsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_chat_v2_object_id_rooms_post`]
#[derive(Clone, Debug)]
pub struct ObjectChatV2ObjectIdRoomsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_room_request: Option<models::CreateRoomRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_coupons_count_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdCouponsCountGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_coupons_post`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdCouponsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub give_coupon_req: Option<models::GiveCouponReq>
}

/// struct for passing parameters to the method [`object_commerce_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub scope: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_listings_cooldown_put`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdListingsCooldownPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub cooldown_modifier_request: Option<models::CooldownModifierRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_listings_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdListingsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub listing: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub store: Option<String>,
    pub time: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_offers_admin_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdOffersAdminGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub language: Option<String>,
    pub time: Option<String>,
    pub stores: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_offers_get`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdOffersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub language: Option<String>,
    pub time: Option<String>,
    pub stores: Option<String>
}

/// struct for passing parameters to the method [`object_commerce_object_id_purchase_post`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdPurchasePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub purchase_request: Option<models::PurchaseRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_purchase_put`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdPurchasePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub report_purchase_request: Option<models::ReportPurchaseRequest>
}

/// struct for passing parameters to the method [`object_commerce_object_id_stats_update_post`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdStatsUpdatePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_subscription_notification: Option<models::StatSubscriptionNotification>
}

/// struct for passing parameters to the method [`object_commerce_object_id_status_delete`]
#[derive(Clone, Debug)]
pub struct ObjectCommerceObjectIdStatusDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub clear_status_request: Option<models::ClearStatusRequest>
}

/// struct for passing parameters to the method [`object_event_players_object_id_claim_post`]
#[derive(Clone, Debug)]
pub struct ObjectEventPlayersObjectIdClaimPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_claim_request: Option<models::EventClaimRequest>
}

/// struct for passing parameters to the method [`object_event_players_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectEventPlayersObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_event_players_object_id_score_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventPlayersObjectIdScorePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_score_request: Option<models::EventScoreRequest>
}

/// struct for passing parameters to the method [`object_events_object_id_content_delete`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdContentDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_events_object_id_content_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdContentPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub set_content_request: Option<models::SetContentRequest>
}

/// struct for passing parameters to the method [`object_events_object_id_end_phase_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdEndPhasePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub event_phase_end_request: Option<models::EventPhaseEndRequest>
}

/// struct for passing parameters to the method [`object_events_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_events_object_id_ping_get`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdPingGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_events_object_id_refresh_put`]
#[derive(Clone, Debug)]
pub struct ObjectEventsObjectIdRefreshPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: events.event_content_id.event_started_timestamp
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_group_users_object_id_availability_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdAvailabilityGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub r#type: models::GroupType,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub name: Option<String>,
    pub tag: Option<String>,
    pub sub_group: Option<bool>
}

/// struct for passing parameters to the method [`object_group_users_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_group_users_object_id_group_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdGroupPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_create: Option<models::GroupCreate>
}

/// struct for passing parameters to the method [`object_group_users_object_id_join_delete`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdJoinDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_membership_request: Option<models::GroupMembershipRequest>
}

/// struct for passing parameters to the method [`object_group_users_object_id_join_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdJoinPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_membership_request: Option<models::GroupMembershipRequest>
}

/// struct for passing parameters to the method [`object_group_users_object_id_recommended_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdRecommendedGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_group_users_object_id_search_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupUsersObjectIdSearchGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub r#type: models::GroupType,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub name: Option<String>,
    pub score_min: Option<i64>,
    pub sort_field: Option<String>,
    pub user_score: Option<i64>,
    pub has_slots: Option<bool>,
    pub enrollment_types: Option<String>,
    pub offset: Option<i32>,
    pub score_max: Option<i64>,
    pub sub_group: Option<bool>,
    pub sort_value: Option<i32>,
    pub limit: Option<i32>
}

/// struct for passing parameters to the method [`object_groups_object_id_apply_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdApplyPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_application: Option<models::GroupApplication>
}

/// struct for passing parameters to the method [`object_groups_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub disband_request: Option<models::DisbandRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_donations_claim_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDonationsClaimPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_groups_object_id_donations_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDonationsPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub create_donation_request: Option<models::CreateDonationRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_donations_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdDonationsPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub make_donation_request: Option<models::MakeDonationRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_groups_object_id_invite_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdInvitePostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_invite: Option<models::GroupInvite>
}

/// struct for passing parameters to the method [`object_groups_object_id_kick_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdKickPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub kick_request: Option<models::KickRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_member_delete`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdMemberDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub kick_request: Option<models::KickRequest>
}

/// struct for passing parameters to the method [`object_groups_object_id_petition_post`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdPetitionPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_application: Option<models::GroupApplication>
}

/// struct for passing parameters to the method [`object_groups_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub group_update: Option<models::GroupUpdate>
}

/// struct for passing parameters to the method [`object_groups_object_id_role_put`]
#[derive(Clone, Debug)]
pub struct ObjectGroupsObjectIdRolePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub role_change_request: Option<models::RoleChangeRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub scope: Option<String>
}

/// struct for passing parameters to the method [`object_inventory_object_id_multipliers_get`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdMultipliersGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_inventory_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub inventory_query_request: Option<models::InventoryQueryRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_preview_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdPreviewPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub inventory_update_request: Option<models::InventoryUpdateRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_proxy_reload_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdProxyReloadPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_inventory_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub inventory_update_request: Option<models::InventoryUpdateRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_transaction_delete`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdTransactionDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub end_transaction_request: Option<models::EndTransactionRequest>
}

/// struct for passing parameters to the method [`object_inventory_object_id_transfer_put`]
#[derive(Clone, Debug)]
pub struct ObjectInventoryObjectIdTransferPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub transfer_request: Option<models::TransferRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_assignment_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdAssignmentDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_remove_cache_entry_request: Option<models::LeaderboardRemoveCacheEntryRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_assignment_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdAssignmentGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_details_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdDetailsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub from: Option<i32>,
    pub max: Option<i32>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_entries_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdEntriesDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_entry_delete`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdEntryDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_remove_entry_request: Option<models::LeaderboardRemoveEntryRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_entry_put`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdEntryPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_add_request: Option<models::LeaderboardAddRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_freeze_put`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdFreezePutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_friends_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdFriendsGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_matches_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdMatchesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub pool_size: i32,
    pub windows: i32,
    pub window_size: i32,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_membership_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdMembershipGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_id: i64,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_partition_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdPartitionGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub player_id: i64,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_create_request: Option<models::LeaderboardCreateRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_ranks_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdRanksGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub ids: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_swap_put`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdSwapPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub leaderboard_swap_request: Option<models::LeaderboardSwapRequest>
}

/// struct for passing parameters to the method [`object_leaderboards_object_id_view_get`]
#[derive(Clone, Debug)]
pub struct ObjectLeaderboardsObjectIdViewGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub max: Option<i32>,
    pub focus: Option<i64>,
    pub friends: Option<bool>,
    pub from: Option<i32>,
    pub outlier: Option<i64>,
    pub guild: Option<bool>
}

/// struct for passing parameters to the method [`object_mail_object_id_accept_many_put`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdAcceptManyPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub accept_multiple_attachments: Option<models::AcceptMultipleAttachments>
}

/// struct for passing parameters to the method [`object_mail_object_id_bulk_post`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdBulkPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub bulk_send_mail_request: Option<models::BulkSendMailRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_bulk_put`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdBulkPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub bulk_update_mail_object_request: Option<models::BulkUpdateMailObjectRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_categories_get`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdCategoriesGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_mail_object_id_detail_get`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdDetailGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    pub mid: i64,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_mail_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`object_mail_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub send_mail_object_request: Option<models::SendMailObjectRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_put`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdPutParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub update_mail_request: Option<models::UpdateMailRequest>
}

/// struct for passing parameters to the method [`object_mail_object_id_search_post`]
#[derive(Clone, Debug)]
pub struct ObjectMailObjectIdSearchPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Gamertag of the player.Underlying objectId type is integer in format int64.
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub mail_search_request: Option<models::MailSearchRequest>
}

/// struct for passing parameters to the method [`object_stats_object_id_client_get`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdClientGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats: Option<String>
}

/// struct for passing parameters to the method [`object_stats_object_id_client_post`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdClientPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_update_request: Option<models::StatUpdateRequest>
}

/// struct for passing parameters to the method [`object_stats_object_id_client_stringlist_post`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdClientStringlistPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_update_request_string_list_format: Option<models::StatUpdateRequestStringListFormat>
}

/// struct for passing parameters to the method [`object_stats_object_id_delete`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdDeleteParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_request: Option<models::StatRequest>
}

/// struct for passing parameters to the method [`object_stats_object_id_get`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdGetParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stats: Option<String>
}

/// struct for passing parameters to the method [`object_stats_object_id_post`]
#[derive(Clone, Debug)]
pub struct ObjectStatsObjectIdPostParams {
    /// Customer and project scope. This should be in the form of '<customer-id>.<project-id>'.
    pub x_beam_scope: String,
    /// Format: domain.visibility.type.gamerTag
    pub object_id: String,
    /// Override the Gamer Tag of the player. This is generally inferred by the auth token.
    pub x_beam_gamertag: Option<String>,
    pub stat_update_request: Option<models::StatUpdateRequest>
}


/// struct for typed errors of method [`basic_accounts_admin_admin_user_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAdminAdminUserPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_admin_admin_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAdminAdminUsersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_admin_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAdminMeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_device_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableDeviceIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_external_identity_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableExternalIdentityGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_available_third_party_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsAvailableThirdPartyGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_email_update_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsEmailUpdateConfirmPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_email_update_init_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsEmailUpdateInitPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_external_identity_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsExternalIdentityDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_external_identity_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsExternalIdentityPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_find_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsFindGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_get_personally_identifiable_information_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsGetPersonallyIdentifiableInformationGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_device_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMeDeviceDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_me_third_party_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsMeThirdPartyDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_password_update_confirm_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsPasswordUpdateConfirmPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_password_update_init_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsPasswordUpdateInitPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_register_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsRegisterPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_accounts_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAccountsSearchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsContentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_list_definitions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsListDefinitionsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsListGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_list_tags_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsListTagsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_announcements_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAnnouncementsSearchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenListGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_auth_token_revoke_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicAuthTokenRevokePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_image_commit_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoImageCommitPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_image_urls_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoImageUrlsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_logs_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoLogsUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_current_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestCurrentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_deploy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestDeployPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifest_pull_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestPullPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_manifests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoManifestsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_metrics_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMetricsUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_federation_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceFederationPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_federation_traffic_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceFederationTrafficDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_federation_traffic_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceFederationTrafficPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_registrations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceRegistrationsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_microservice_secret_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoMicroserviceSecretGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_query_logs_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoQueryLogsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_query_logs_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoQueryLogsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_query_logs_result_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoQueryLogsResultPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_registry_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoRegistryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoStatusGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_storage_connection_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoStorageConnectionGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_storage_performance_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoStoragePerformanceGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoTemplatesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_beamo_upload_api_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicBeamoUploadApiGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_commit_manifest_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataCommitManifestPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_download_url_from_portal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataDownloadUrlFromPortalPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_download_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataDownloadUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_move_from_portal_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataMoveFromPortalPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_move_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataMovePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_replace_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataReplacePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_upload_url_from_portal_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataUploadUrlFromPortalPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_data_upload_url_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingDataUploadUrlPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_cloudsaving_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCloudsavingGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_catalog_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceCatalogGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_catalog_legacy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceCatalogLegacyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_skus_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceSkusGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_commerce_skus_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicCommerceSkusPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_binary_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentBinaryPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentContentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_localizations_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentLocalizationsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_localizations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentLocalizationsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_localizations_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentLocalizationsPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_checksum_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestChecksumGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_checksums_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestChecksumsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_exact_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestExactGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestHistoryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_private_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPrivateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_private_json_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPrivateJsonGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_public_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPublicGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_public_json_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPublicJsonGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_pull_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestPullPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifest_repeat_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestRepeatPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_archive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsArchivePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_pull_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsPullPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_manifests_unarchive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentManifestsUnarchivePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_content_text_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicContentTextPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_apply_content_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsApplyContentPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_calendar_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsCalendarGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_content_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsContentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_events_running_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicEventsRunningGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_inventory_currency_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicInventoryCurrencyGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_inventory_items_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicInventoryItemsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_assignment_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsAssignmentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_list_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsListGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_player_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsPlayerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_leaderboards_uid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicLeaderboardsUidGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_attachments_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailAttachmentsPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_bulk_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailBulkPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_mail_template_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicMailTemplateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_channel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationChannelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_custom_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationCustomPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_game_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationGamePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_generic_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationGenericPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_player_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationPlayerPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_notification_server_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicNotificationServerPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_audits_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsAuditsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_coupon_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsCouponPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_update_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookUpdateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_facebook_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsFacebookUpdatePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_googleplay_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsGoogleplayPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_itunes_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsItunesPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_auth_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamAuthPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_order_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamOrderGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_prices_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPricesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_products_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamProductsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_steam_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsSteamPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_test_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsTestPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_product_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsProductGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_begin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseBeginPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseCancelPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseCompletePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_fail_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseFailPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_track_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseTrackPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_payments_windows_purchase_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPaymentsWindowsPurchaseVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_push_register_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPushRegisterPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_push_send_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicPushSendPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_admin_customer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsAdminCustomerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_admin_inflight_failures_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsAdminInflightFailuresDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_admin_inflight_failures_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsAdminInflightFailuresGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_client_defaults_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsClientDefaultsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsConfigGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_config_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsConfigPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsConfigPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_activate_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerActivateGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_alias_available_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerAliasAvailableGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customer_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomerVerifyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_customers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsCustomersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_game_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGameGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_game_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGamePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_game_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGamePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_games_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsGamesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_is_customer_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsIsCustomerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_launch_message_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsLaunchMessageDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_launch_message_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsLaunchMessageGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_launch_message_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsLaunchMessagePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_plans_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPlansGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_plans_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPlansPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_beamable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectBeamablePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_promote_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPromoteGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_promote_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPromotePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_project_rename_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsProjectRenamePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_promotion_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPromotionGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_realms_promotion_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicRealmsPromotionPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_client_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionClientHistoryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_heartbeat_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionHeartbeatPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionHistoryGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_session_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSessionStatusGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_blocked_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialBlockedDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_blocked_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialBlockedPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsImportPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_invite_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsInviteDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_invite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsInvitePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_friends_make_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialFriendsMakePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_social_my_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicSocialMyGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsBatchPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_client_batch_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsClientBatchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_search_extended_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSearchExtendedPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSearchPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_subscribe_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSubscribeDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_stats_subscribe_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicStatsSubscribePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_admin_player_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsAdminPlayerGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_admin_player_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsAdminPlayerPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_champions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsChampionsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_global_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsGlobalGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsGroupsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsMeGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_me_group_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsMeGroupGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_rewards_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsRewardsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_rewards_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsRewardsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_score_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsScorePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_search_groups_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsSearchGroupsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_standings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsStandingsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_tournaments_standings_group_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTournamentsStandingsGroupGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_admin_data_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsAdminDataGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_admin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsAdminGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_data_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsDataDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_data_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsDataPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_pause_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsPausePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_schedule_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsSchedulePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`basic_trials_start_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BasicTrialsStartPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_email_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminEmailPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_forget_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminForgetDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_scope_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminScopeDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_scope_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminScopePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_third_party_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminThirdPartyDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_admin_third_party_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAdminThirdPartyPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_available_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdAvailableRolesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_role_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdRoleDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_role_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdRolePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_accounts_object_id_role_report_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAccountsObjectIdRoleReportGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_claim_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdClaimPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_raw_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdRawGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_announcements_object_id_read_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectAnnouncementsObjectIdReadPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_calendars_object_id_claim_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCalendarsObjectIdClaimPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_calendars_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCalendarsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_messages_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdMessagesPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_rooms_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdRoomsDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_rooms_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdRoomsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_chat_v2_object_id_rooms_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectChatV2ObjectIdRoomsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_coupons_count_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdCouponsCountGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_coupons_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdCouponsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_listings_cooldown_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdListingsCooldownPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_listings_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdListingsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_offers_admin_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdOffersAdminGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_offers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdOffersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_purchase_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdPurchasePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_purchase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdPurchasePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_stats_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdStatsUpdatePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_commerce_object_id_status_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectCommerceObjectIdStatusDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_event_players_object_id_claim_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventPlayersObjectIdClaimPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_event_players_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventPlayersObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_event_players_object_id_score_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventPlayersObjectIdScorePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_content_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdContentDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_content_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdContentPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_end_phase_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdEndPhasePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_ping_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdPingGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_events_object_id_refresh_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectEventsObjectIdRefreshPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_availability_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdAvailabilityGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_group_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdGroupPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_join_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdJoinDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_join_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdJoinPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_recommended_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdRecommendedGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_group_users_object_id_search_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupUsersObjectIdSearchGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_apply_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdApplyPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_donations_claim_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDonationsClaimPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_donations_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDonationsPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_donations_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdDonationsPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_invite_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdInvitePostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_kick_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdKickPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_member_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdMemberDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_petition_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdPetitionPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_groups_object_id_role_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectGroupsObjectIdRolePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_multipliers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdMultipliersGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_preview_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdPreviewPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_proxy_reload_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdProxyReloadPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_transaction_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdTransactionDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_inventory_object_id_transfer_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectInventoryObjectIdTransferPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_assignment_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdAssignmentDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_assignment_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdAssignmentGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_details_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdDetailsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_entries_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdEntriesDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_entry_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdEntryDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_entry_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdEntryPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_freeze_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdFreezePutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_friends_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdFriendsGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_matches_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdMatchesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_membership_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdMembershipGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_partition_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdPartitionGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_ranks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdRanksGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_swap_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdSwapPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_leaderboards_object_id_view_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectLeaderboardsObjectIdViewGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_accept_many_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdAcceptManyPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_bulk_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdBulkPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_bulk_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdBulkPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_categories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdCategoriesGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_detail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdDetailGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdPutError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_mail_object_id_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectMailObjectIdSearchPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_client_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdClientGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_client_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdClientPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_client_stringlist_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdClientStringlistPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdDeleteError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdGetError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_stats_object_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectStatsObjectIdPostError {
    Status400(),
    UnknownValue(serde_json::Value),
}


pub async fn basic_accounts_admin_admin_user_post(configuration: &configuration::Configuration, params: BasicAccountsAdminAdminUserPostParams) -> Result<models::AccountPortalView, Error<BasicAccountsAdminAdminUserPostError>> {

    let uri_str = format!("{}/basic/accounts/admin/admin-user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_elevated_account_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPortalView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPortalView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAdminAdminUserPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_admin_admin_users_get(configuration: &configuration::Configuration, params: BasicAccountsAdminAdminUsersGetParams) -> Result<models::GetAdminsResponse, Error<BasicAccountsAdminAdminUsersGetError>> {

    let uri_str = format!("{}/basic/accounts/admin/admin-users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAdminsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAdminsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAdminAdminUsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_admin_me_get(configuration: &configuration::Configuration, params: BasicAccountsAdminMeGetParams) -> Result<models::AccountPortalView, Error<BasicAccountsAdminMeGetError>> {

    let uri_str = format!("{}/basic/accounts/admin/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPortalView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPortalView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAdminMeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_available_device_id_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableDeviceIdGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableDeviceIdGetError>> {

    let uri_str = format!("{}/basic/accounts/available/device-id", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("deviceId", &params.device_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAvailableDeviceIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_available_external_identity_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableExternalIdentityGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableExternalIdentityGetError>> {

    let uri_str = format!("{}/basic/accounts/available/external_identity", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("provider_service", &params.provider_service.to_string())]);
    req_builder = req_builder.query(&[("user_id", &params.user_id.to_string())]);
    if let Some(ref param_value) = params.provider_namespace {
        req_builder = req_builder.query(&[("provider_namespace", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAvailableExternalIdentityGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_available_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableGetError>> {

    let uri_str = format!("{}/basic/accounts/available", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("email", &params.email.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAvailableGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_available_third_party_get(configuration: &configuration::Configuration, params: BasicAccountsAvailableThirdPartyGetParams) -> Result<models::AccountAvailableResponse, Error<BasicAccountsAvailableThirdPartyGetError>> {

    let uri_str = format!("{}/basic/accounts/available/third-party", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("thirdParty", &params.third_party.to_string())]);
    req_builder = req_builder.query(&[("token", &params.token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsAvailableThirdPartyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_email_update_confirm_post(configuration: &configuration::Configuration, params: BasicAccountsEmailUpdateConfirmPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsEmailUpdateConfirmPostError>> {

    let uri_str = format!("{}/basic/accounts/email-update/confirm", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.email_update_confirmation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsEmailUpdateConfirmPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_email_update_init_post(configuration: &configuration::Configuration, params: BasicAccountsEmailUpdateInitPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsEmailUpdateInitPostError>> {

    let uri_str = format!("{}/basic/accounts/email-update/init", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.email_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsEmailUpdateInitPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_external_identity_delete(configuration: &configuration::Configuration, params: BasicAccountsExternalIdentityDeleteParams) -> Result<models::CommonResponse, Error<BasicAccountsExternalIdentityDeleteError>> {

    let uri_str = format!("{}/basic/accounts/external_identity", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_external_identity_api_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsExternalIdentityDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_external_identity_post(configuration: &configuration::Configuration, params: BasicAccountsExternalIdentityPostParams) -> Result<models::AttachExternalIdentityApiResponse, Error<BasicAccountsExternalIdentityPostError>> {

    let uri_str = format!("{}/basic/accounts/external_identity", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.attach_external_identity_api_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AttachExternalIdentityApiResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AttachExternalIdentityApiResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsExternalIdentityPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_find_get(configuration: &configuration::Configuration, params: BasicAccountsFindGetParams) -> Result<models::Account, Error<BasicAccountsFindGetError>> {

    let uri_str = format!("{}/basic/accounts/find", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &params.query.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Account`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Account`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsFindGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_get_personally_identifiable_information_get(configuration: &configuration::Configuration, params: BasicAccountsGetPersonallyIdentifiableInformationGetParams) -> Result<models::AccountPersonallyIdentifiableInformationResponse, Error<BasicAccountsGetPersonallyIdentifiableInformationGetError>> {

    let uri_str = format!("{}/basic/accounts/get-personally-identifiable-information", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &params.query.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPersonallyIdentifiableInformationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPersonallyIdentifiableInformationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsGetPersonallyIdentifiableInformationGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_me_device_delete(configuration: &configuration::Configuration, params: BasicAccountsMeDeviceDeleteParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMeDeviceDeleteError>> {

    let uri_str = format!("{}/basic/accounts/me/device", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_devices_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPlayerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPlayerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsMeDeviceDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_me_get(configuration: &configuration::Configuration, params: BasicAccountsMeGetParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMeGetError>> {

    let uri_str = format!("{}/basic/accounts/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPlayerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPlayerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsMeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_me_put(configuration: &configuration::Configuration, params: BasicAccountsMePutParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMePutError>> {

    let uri_str = format!("{}/basic/accounts/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.account_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPlayerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPlayerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsMePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_me_third_party_delete(configuration: &configuration::Configuration, params: BasicAccountsMeThirdPartyDeleteParams) -> Result<models::AccountPlayerView, Error<BasicAccountsMeThirdPartyDeleteError>> {

    let uri_str = format!("{}/basic/accounts/me/third-party", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.third_party_available_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPlayerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPlayerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsMeThirdPartyDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_password_update_confirm_post(configuration: &configuration::Configuration, params: BasicAccountsPasswordUpdateConfirmPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsPasswordUpdateConfirmPostError>> {

    let uri_str = format!("{}/basic/accounts/password-update/confirm", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.password_update_confirmation);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsPasswordUpdateConfirmPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_password_update_init_post(configuration: &configuration::Configuration, params: BasicAccountsPasswordUpdateInitPostParams) -> Result<models::EmptyResponse, Error<BasicAccountsPasswordUpdateInitPostError>> {

    let uri_str = format!("{}/basic/accounts/password-update/init", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.password_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsPasswordUpdateInitPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_register_post(configuration: &configuration::Configuration, params: BasicAccountsRegisterPostParams) -> Result<models::AccountPlayerView, Error<BasicAccountsRegisterPostError>> {

    let uri_str = format!("{}/basic/accounts/register", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.account_registration);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountPlayerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountPlayerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsRegisterPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_accounts_search_get(configuration: &configuration::Configuration, params: BasicAccountsSearchGetParams) -> Result<models::AccountSearchResponse, Error<BasicAccountsSearchGetError>> {

    let uri_str = format!("{}/basic/accounts/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("query", &params.query.to_string())]);
    req_builder = req_builder.query(&[("page", &params.page.to_string())]);
    req_builder = req_builder.query(&[("pagesize", &params.pagesize.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAccountsSearchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_content_get(configuration: &configuration::Configuration, params: BasicAnnouncementsContentGetParams) -> Result<models::AnnouncementContentResponse, Error<BasicAnnouncementsContentGetError>> {

    let uri_str = format!("{}/basic/announcements/content", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AnnouncementContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AnnouncementContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsContentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_delete(configuration: &configuration::Configuration, params: BasicAnnouncementsDeleteParams) -> Result<models::EmptyResponse, Error<BasicAnnouncementsDeleteError>> {

    let uri_str = format!("{}/basic/announcements/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_announcement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_list_definitions_get(configuration: &configuration::Configuration, params: BasicAnnouncementsListDefinitionsGetParams) -> Result<models::ListDefinitionsResponse, Error<BasicAnnouncementsListDefinitionsGetError>> {

    let uri_str = format!("{}/basic/announcements/list/definitions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListDefinitionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListDefinitionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsListDefinitionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_list_get(configuration: &configuration::Configuration, params: BasicAnnouncementsListGetParams) -> Result<models::AnnouncementContentResponse, Error<BasicAnnouncementsListGetError>> {

    let uri_str = format!("{}/basic/announcements/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AnnouncementContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AnnouncementContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_list_tags_get(configuration: &configuration::Configuration, params: BasicAnnouncementsListTagsGetParams) -> Result<models::ListTagsResponse, Error<BasicAnnouncementsListTagsGetError>> {

    let uri_str = format!("{}/basic/announcements/list/tags", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.tag_name_filter {
        req_builder = req_builder.query(&[("tagNameFilter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListTagsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListTagsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsListTagsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_post(configuration: &configuration::Configuration, params: BasicAnnouncementsPostParams) -> Result<models::EmptyResponse, Error<BasicAnnouncementsPostError>> {

    let uri_str = format!("{}/basic/announcements/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.announcement_dto);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_announcements_search_get(configuration: &configuration::Configuration, params: BasicAnnouncementsSearchGetParams) -> Result<models::AnnouncementContentResponse, Error<BasicAnnouncementsSearchGetError>> {

    let uri_str = format!("{}/basic/announcements/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AnnouncementContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AnnouncementContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAnnouncementsSearchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_auth_token_get(configuration: &configuration::Configuration, params: BasicAuthTokenGetParams) -> Result<models::Token, Error<BasicAuthTokenGetError>> {

    let uri_str = format!("{}/basic/auth/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("token", &params.token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Token`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Token`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAuthTokenGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_auth_token_list_get(configuration: &configuration::Configuration, params: BasicAuthTokenListGetParams) -> Result<models::ListTokenResponse, Error<BasicAuthTokenListGetError>> {

    let uri_str = format!("{}/basic/auth/token/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("pageSize", &params.page_size.to_string())]);
    req_builder = req_builder.query(&[("page", &params.page.to_string())]);
    if let Some(ref param_value) = params.cid {
        req_builder = req_builder.query(&[("cid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pid {
        req_builder = req_builder.query(&[("pid", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("gamerTagOrAccountId", &params.gamer_tag_or_account_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAuthTokenListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_auth_token_post(configuration: &configuration::Configuration, params: BasicAuthTokenPostParams) -> Result<models::TokenResponse, Error<BasicAuthTokenPostError>> {

    let uri_str = format!("{}/basic/auth/token", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.token_request_wrapper);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAuthTokenPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_auth_token_revoke_put(configuration: &configuration::Configuration, params: BasicAuthTokenRevokePutParams) -> Result<models::CommonResponse, Error<BasicAuthTokenRevokePutError>> {

    let uri_str = format!("{}/basic/auth/token/revoke", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.revoke_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicAuthTokenRevokePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_image_commit_put(configuration: &configuration::Configuration, params: BasicBeamoImageCommitPutParams) -> Result<models::LambdaResponse, Error<BasicBeamoImageCommitPutError>> {

    let uri_str = format!("{}/basic/beamo/image/commit", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.commit_image_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LambdaResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LambdaResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoImageCommitPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_image_urls_post(configuration: &configuration::Configuration, params: BasicBeamoImageUrlsPostParams) -> Result<models::PreSignedUrlsResponse, Error<BasicBeamoImageUrlsPostError>> {

    let uri_str = format!("{}/basic/beamo/image/urls", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.get_service_urls_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreSignedUrlsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreSignedUrlsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoImageUrlsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_logs_url_post(configuration: &configuration::Configuration, params: BasicBeamoLogsUrlPostParams) -> Result<models::GetSignedUrlResponse, Error<BasicBeamoLogsUrlPostError>> {

    let uri_str = format!("{}/basic/beamo/logsUrl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.get_logs_url_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSignedUrlResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSignedUrlResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoLogsUrlPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_manifest_current_get(configuration: &configuration::Configuration, params: BasicBeamoManifestCurrentGetParams) -> Result<models::GetCurrentManifestResponse, Error<BasicBeamoManifestCurrentGetError>> {

    let uri_str = format!("{}/basic/beamo/manifest/current", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.archived {
        req_builder = req_builder.query(&[("archived", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCurrentManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCurrentManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoManifestCurrentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_manifest_deploy_post(configuration: &configuration::Configuration, params: BasicBeamoManifestDeployPostParams) -> Result<models::EmptyResponse, Error<BasicBeamoManifestDeployPostError>> {

    let uri_str = format!("{}/basic/beamo/manifest/deploy", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoManifestDeployPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_manifest_get(configuration: &configuration::Configuration, params: BasicBeamoManifestGetParams) -> Result<models::GetManifestResponse, Error<BasicBeamoManifestGetError>> {

    let uri_str = format!("{}/basic/beamo/manifest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &params.id.to_string())]);
    if let Some(ref param_value) = params.archived {
        req_builder = req_builder.query(&[("archived", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoManifestGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_manifest_post(configuration: &configuration::Configuration, params: BasicBeamoManifestPostParams) -> Result<models::PostManifestResponse, Error<BasicBeamoManifestPostError>> {

    let uri_str = format!("{}/basic/beamo/manifest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.beamo_basic_post_manifest_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoManifestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_manifest_pull_post(configuration: &configuration::Configuration, params: BasicBeamoManifestPullPostParams) -> Result<models::BeamoBasicManifestChecksums, Error<BasicBeamoManifestPullPostError>> {

    let uri_str = format!("{}/basic/beamo/manifest/pull", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.pull_beamo_manifest_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeamoBasicManifestChecksums`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeamoBasicManifestChecksums`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoManifestPullPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_manifests_get(configuration: &configuration::Configuration, params: BasicBeamoManifestsGetParams) -> Result<models::BeamoBasicGetManifestsResponse, Error<BasicBeamoManifestsGetError>> {

    let uri_str = format!("{}/basic/beamo/manifests", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.archived {
        req_builder = req_builder.query(&[("archived", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeamoBasicGetManifestsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeamoBasicGetManifestsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoManifestsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_metrics_url_post(configuration: &configuration::Configuration, params: BasicBeamoMetricsUrlPostParams) -> Result<models::GetSignedUrlResponse, Error<BasicBeamoMetricsUrlPostError>> {

    let uri_str = format!("{}/basic/beamo/metricsUrl", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.get_metrics_url_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSignedUrlResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSignedUrlResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoMetricsUrlPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_microservice_federation_post(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceFederationPostParams) -> Result<models::SupportedFederationsResponse, Error<BasicBeamoMicroserviceFederationPostError>> {

    let uri_str = format!("{}/basic/beamo/microservice/federation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.microservice_registrations_query);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SupportedFederationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SupportedFederationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoMicroserviceFederationPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_microservice_federation_traffic_delete(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceFederationTrafficDeleteParams) -> Result<models::CommonResponse, Error<BasicBeamoMicroserviceFederationTrafficDeleteError>> {

    let uri_str = format!("{}/basic/beamo/microservice/federation/traffic", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.microservice_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoMicroserviceFederationTrafficDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_microservice_federation_traffic_put(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceFederationTrafficPutParams) -> Result<models::CommonResponse, Error<BasicBeamoMicroserviceFederationTrafficPutError>> {

    let uri_str = format!("{}/basic/beamo/microservice/federation/traffic", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.microservice_registration_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoMicroserviceFederationTrafficPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_microservice_registrations_post(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceRegistrationsPostParams) -> Result<models::MicroserviceRegistrationsResponse, Error<BasicBeamoMicroserviceRegistrationsPostError>> {

    let uri_str = format!("{}/basic/beamo/microservice/registrations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.microservice_registrations_query);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MicroserviceRegistrationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MicroserviceRegistrationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoMicroserviceRegistrationsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_microservice_secret_get(configuration: &configuration::Configuration, params: BasicBeamoMicroserviceSecretGetParams) -> Result<models::MicroserviceSecretResponse, Error<BasicBeamoMicroserviceSecretGetError>> {

    let uri_str = format!("{}/basic/beamo/microservice/secret", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MicroserviceSecretResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MicroserviceSecretResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoMicroserviceSecretGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_query_logs_delete(configuration: &configuration::Configuration, params: BasicBeamoQueryLogsDeleteParams) -> Result<models::CommonResponse, Error<BasicBeamoQueryLogsDeleteError>> {

    let uri_str = format!("{}/basic/beamo/queryLogs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.query);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoQueryLogsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_query_logs_post(configuration: &configuration::Configuration, params: BasicBeamoQueryLogsPostParams) -> Result<models::Query, Error<BasicBeamoQueryLogsPostError>> {

    let uri_str = format!("{}/basic/beamo/queryLogs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.get_logs_insight_url_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Query`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Query`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoQueryLogsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_query_logs_result_post(configuration: &configuration::Configuration, params: BasicBeamoQueryLogsResultPostParams) -> Result<models::GetSignedUrlResponse, Error<BasicBeamoQueryLogsResultPostError>> {

    let uri_str = format!("{}/basic/beamo/queryLogs/result", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.query);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSignedUrlResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSignedUrlResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoQueryLogsResultPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_registry_get(configuration: &configuration::Configuration, params: BasicBeamoRegistryGetParams) -> Result<models::GetElasticContainerRegistryUri, Error<BasicBeamoRegistryGetError>> {

    let uri_str = format!("{}/basic/beamo/registry", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetElasticContainerRegistryUri`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetElasticContainerRegistryUri`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoRegistryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_status_get(configuration: &configuration::Configuration, params: BasicBeamoStatusGetParams) -> Result<models::BeamoBasicGetStatusResponse, Error<BasicBeamoStatusGetError>> {

    let uri_str = format!("{}/basic/beamo/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeamoBasicGetStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeamoBasicGetStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_storage_connection_get(configuration: &configuration::Configuration, params: BasicBeamoStorageConnectionGetParams) -> Result<models::ConnectionString, Error<BasicBeamoStorageConnectionGetError>> {

    let uri_str = format!("{}/basic/beamo/storage/connection", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConnectionString`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConnectionString`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoStorageConnectionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_storage_performance_get(configuration: &configuration::Configuration, params: BasicBeamoStoragePerformanceGetParams) -> Result<models::PerformanceResponse, Error<BasicBeamoStoragePerformanceGetError>> {

    let uri_str = format!("{}/basic/beamo/storage/performance", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.end_date {
        req_builder = req_builder.query(&[("endDate", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("storageObjectName", &params.storage_object_name.to_string())]);
    req_builder = req_builder.query(&[("granularity", &params.granularity.to_string())]);
    if let Some(ref param_value) = params.start_date {
        req_builder = req_builder.query(&[("startDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PerformanceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PerformanceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoStoragePerformanceGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_templates_get(configuration: &configuration::Configuration, params: BasicBeamoTemplatesGetParams) -> Result<models::BeamoBasicGetTemplatesResponse, Error<BasicBeamoTemplatesGetError>> {

    let uri_str = format!("{}/basic/beamo/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeamoBasicGetTemplatesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeamoBasicGetTemplatesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoTemplatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_beamo_upload_api_get(configuration: &configuration::Configuration, params: BasicBeamoUploadApiGetParams) -> Result<models::GetLambdaUri, Error<BasicBeamoUploadApiGetError>> {

    let uri_str = format!("{}/basic/beamo/uploadAPI", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLambdaUri`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLambdaUri`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicBeamoUploadApiGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_commit_manifest_put(configuration: &configuration::Configuration, params: BasicCloudsavingDataCommitManifestPutParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataCommitManifestPutError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/commitManifest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.upload_requests);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CloudsavingBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CloudsavingBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataCommitManifestPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_delete(configuration: &configuration::Configuration, params: BasicCloudsavingDataDeleteParams) -> Result<models::EmptyResponse, Error<BasicCloudsavingDataDeleteError>> {

    let uri_str = format!("{}/basic/cloudsaving/data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.object_requests);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_download_url_from_portal_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataDownloadUrlFromPortalPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataDownloadUrlFromPortalPostError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/downloadURLFromPortal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.object_requests);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UrlsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UrlsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataDownloadUrlFromPortalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_download_url_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataDownloadUrlPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataDownloadUrlPostError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/downloadURL", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.object_requests);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UrlsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UrlsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataDownloadUrlPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_move_from_portal_put(configuration: &configuration::Configuration, params: BasicCloudsavingDataMoveFromPortalPutParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataMoveFromPortalPutError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/moveFromPortal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.player_basic_cloud_data_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CloudsavingBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CloudsavingBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataMoveFromPortalPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_move_put(configuration: &configuration::Configuration, params: BasicCloudsavingDataMovePutParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataMovePutError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/move", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.player_basic_cloud_data_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CloudsavingBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CloudsavingBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataMovePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_replace_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataReplacePostParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingDataReplacePostError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/replace", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.replace_objects_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CloudsavingBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CloudsavingBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataReplacePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_upload_url_from_portal_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataUploadUrlFromPortalPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataUploadUrlFromPortalPostError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/uploadURLFromPortal", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.upload_requests_from_portal);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UrlsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UrlsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataUploadUrlFromPortalPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_data_upload_url_post(configuration: &configuration::Configuration, params: BasicCloudsavingDataUploadUrlPostParams) -> Result<models::UrlsResponse, Error<BasicCloudsavingDataUploadUrlPostError>> {

    let uri_str = format!("{}/basic/cloudsaving/data/uploadURL", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.upload_requests);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UrlsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UrlsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingDataUploadUrlPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_cloudsaving_get(configuration: &configuration::Configuration, params: BasicCloudsavingGetParams) -> Result<models::CloudsavingBasicManifest, Error<BasicCloudsavingGetError>> {

    let uri_str = format!("{}/basic/cloudsaving/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.player_id {
        req_builder = req_builder.query(&[("playerId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CloudsavingBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CloudsavingBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCloudsavingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_commerce_catalog_get(configuration: &configuration::Configuration, params: BasicCommerceCatalogGetParams) -> Result<models::GetCatalogResponse, Error<BasicCommerceCatalogGetError>> {

    let uri_str = format!("{}/basic/commerce/catalog", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCatalogResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCatalogResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCommerceCatalogGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_commerce_catalog_legacy_post(configuration: &configuration::Configuration, params: BasicCommerceCatalogLegacyPostParams) -> Result<models::ResultResponse, Error<BasicCommerceCatalogLegacyPostError>> {

    let uri_str = format!("{}/basic/commerce/catalog/legacy", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.save_catalog_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCommerceCatalogLegacyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_commerce_skus_get(configuration: &configuration::Configuration, params: BasicCommerceSkusGetParams) -> Result<models::GetSkusResponse, Error<BasicCommerceSkusGetError>> {

    let uri_str = format!("{}/basic/commerce/skus", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSkusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSkusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCommerceSkusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_commerce_skus_post(configuration: &configuration::Configuration, params: BasicCommerceSkusPostParams) -> Result<models::ResultResponse, Error<BasicCommerceSkusPostError>> {

    let uri_str = format!("{}/basic/commerce/skus", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.save_skus_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicCommerceSkusPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_binary_post(configuration: &configuration::Configuration, params: BasicContentBinaryPostParams) -> Result<models::SaveBinaryResponse, Error<BasicContentBinaryPostError>> {

    let uri_str = format!("{}/basic/content/binary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.save_binary_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SaveBinaryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SaveBinaryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentBinaryPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_content_get(configuration: &configuration::Configuration, params: BasicContentContentGetParams) -> Result<models::ContentOrText, Error<BasicContentContentGetError>> {

    let uri_str = format!("{}/basic/content/content", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("contentId", &params.content_id.to_string())]);
    req_builder = req_builder.query(&[("version", &params.version.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentOrText`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentOrText`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentContentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_localizations_delete(configuration: &configuration::Configuration, params: BasicContentLocalizationsDeleteParams) -> Result<models::CommonResponse, Error<BasicContentLocalizationsDeleteError>> {

    let uri_str = format!("{}/basic/content/localizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_localization_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentLocalizationsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_localizations_get(configuration: &configuration::Configuration, params: BasicContentLocalizationsGetParams) -> Result<models::GetLocalizationsResponse, Error<BasicContentLocalizationsGetError>> {

    let uri_str = format!("{}/basic/content/localizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetLocalizationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetLocalizationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentLocalizationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_localizations_put(configuration: &configuration::Configuration, params: BasicContentLocalizationsPutParams) -> Result<models::CommonResponse, Error<BasicContentLocalizationsPutError>> {

    let uri_str = format!("{}/basic/content/localizations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.put_localizations_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentLocalizationsPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_checksum_get(configuration: &configuration::Configuration, params: BasicContentManifestChecksumGetParams) -> Result<models::ContentBasicManifestChecksum, Error<BasicContentManifestChecksumGetError>> {

    let uri_str = format!("{}/basic/content/manifest/checksum", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.uid {
        req_builder = req_builder.query(&[("uid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifestChecksum`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifestChecksum`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestChecksumGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_checksums_get(configuration: &configuration::Configuration, params: BasicContentManifestChecksumsGetParams) -> Result<models::ContentBasicManifestChecksums, Error<BasicContentManifestChecksumsGetError>> {

    let uri_str = format!("{}/basic/content/manifest/checksums", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifestChecksums`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifestChecksums`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestChecksumsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_exact_get(configuration: &configuration::Configuration, params: BasicContentManifestExactGetParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestExactGetError>> {

    let uri_str = format!("{}/basic/content/manifest/exact", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("uid", &params.uid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestExactGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_get(configuration: &configuration::Configuration, params: BasicContentManifestGetParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestGetError>> {

    let uri_str = format!("{}/basic/content/manifest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.uid {
        req_builder = req_builder.query(&[("uid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_history_get(configuration: &configuration::Configuration, params: BasicContentManifestHistoryGetParams) -> Result<models::GetManifestHistoryResponse, Error<BasicContentManifestHistoryGetError>> {

    let uri_str = format!("{}/basic/content/manifest/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetManifestHistoryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetManifestHistoryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_post(configuration: &configuration::Configuration, params: BasicContentManifestPostParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestPostError>> {

    let uri_str = format!("{}/basic/content/manifest", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.save_manifest_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_private_get(configuration: &configuration::Configuration, params: BasicContentManifestPrivateGetParams) -> Result<models::ClientManifestResponse, Error<BasicContentManifestPrivateGetError>> {

    let uri_str = format!("{}/basic/content/manifest/private", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.uid {
        req_builder = req_builder.query(&[("uid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestPrivateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_private_json_get(configuration: &configuration::Configuration, params: BasicContentManifestPrivateJsonGetParams) -> Result<models::ClientManifestJsonResponse, Error<BasicContentManifestPrivateJsonGetError>> {

    let uri_str = format!("{}/basic/content/manifest/private/json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.uid {
        req_builder = req_builder.query(&[("uid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientManifestJsonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientManifestJsonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestPrivateJsonGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_public_get(configuration: &configuration::Configuration, params: BasicContentManifestPublicGetParams) -> Result<models::ClientManifestResponse, Error<BasicContentManifestPublicGetError>> {

    let uri_str = format!("{}/basic/content/manifest/public", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.uid {
        req_builder = req_builder.query(&[("uid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientManifestResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientManifestResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestPublicGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_public_json_get(configuration: &configuration::Configuration, params: BasicContentManifestPublicJsonGetParams) -> Result<models::ClientManifestJsonResponse, Error<BasicContentManifestPublicJsonGetError>> {

    let uri_str = format!("{}/basic/content/manifest/public/json", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.id {
        req_builder = req_builder.query(&[("id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.uid {
        req_builder = req_builder.query(&[("uid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ClientManifestJsonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ClientManifestJsonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestPublicJsonGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_pull_post(configuration: &configuration::Configuration, params: BasicContentManifestPullPostParams) -> Result<models::ContentBasicManifest, Error<BasicContentManifestPullPostError>> {

    let uri_str = format!("{}/basic/content/manifest/pull", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.pull_manifest_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestPullPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifest_repeat_put(configuration: &configuration::Configuration, params: BasicContentManifestRepeatPutParams) -> Result<models::CommonResponse, Error<BasicContentManifestRepeatPutError>> {

    let uri_str = format!("{}/basic/content/manifest/repeat", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.repeat_manifest_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestRepeatPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifests_archive_post(configuration: &configuration::Configuration, params: BasicContentManifestsArchivePostParams) -> Result<models::EmptyResponse, Error<BasicContentManifestsArchivePostError>> {

    let uri_str = format!("{}/basic/content/manifests/archive", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.archive_or_unarchive_manifests_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestsArchivePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifests_get(configuration: &configuration::Configuration, params: BasicContentManifestsGetParams) -> Result<models::ContentBasicGetManifestsResponse, Error<BasicContentManifestsGetError>> {

    let uri_str = format!("{}/basic/content/manifests", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicGetManifestsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicGetManifestsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifests_pull_post(configuration: &configuration::Configuration, params: BasicContentManifestsPullPostParams) -> Result<models::ContentBasicManifestChecksums, Error<BasicContentManifestsPullPostError>> {

    let uri_str = format!("{}/basic/content/manifests/pull", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.pull_all_manifests_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ContentBasicManifestChecksums`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ContentBasicManifestChecksums`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestsPullPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_manifests_unarchive_post(configuration: &configuration::Configuration, params: BasicContentManifestsUnarchivePostParams) -> Result<models::EmptyResponse, Error<BasicContentManifestsUnarchivePostError>> {

    let uri_str = format!("{}/basic/content/manifests/unarchive", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.archive_or_unarchive_manifests_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentManifestsUnarchivePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_post(configuration: &configuration::Configuration, params: BasicContentPostParams) -> Result<models::SaveContentResponse, Error<BasicContentPostError>> {

    let uri_str = format!("{}/basic/content/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.save_content_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SaveContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SaveContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_content_text_post(configuration: &configuration::Configuration, params: BasicContentTextPostParams) -> Result<models::SaveTextResponse, Error<BasicContentTextPostError>> {

    let uri_str = format!("{}/basic/content/text", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.save_text_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SaveTextResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SaveTextResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicContentTextPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_events_apply_content_post(configuration: &configuration::Configuration, params: BasicEventsApplyContentPostParams) -> Result<models::CommonResponse, Error<BasicEventsApplyContentPostError>> {

    let uri_str = format!("{}/basic/events/applyContent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.event_apply_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicEventsApplyContentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_events_calendar_get(configuration: &configuration::Configuration, params: BasicEventsCalendarGetParams) -> Result<models::EventsInDateRangeResponse, Error<BasicEventsCalendarGetError>> {

    let uri_str = format!("{}/basic/events/calendar", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventsInDateRangeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventsInDateRangeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicEventsCalendarGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_events_content_get(configuration: &configuration::Configuration, params: BasicEventsContentGetParams) -> Result<models::EventContentResponse, Error<BasicEventsContentGetError>> {

    let uri_str = format!("{}/basic/events/content", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicEventsContentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_events_running_get(configuration: &configuration::Configuration, params: BasicEventsRunningGetParams) -> Result<models::EventQueryResponse, Error<BasicEventsRunningGetError>> {

    let uri_str = format!("{}/basic/events/running", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicEventsRunningGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_inventory_currency_get(configuration: &configuration::Configuration, params: BasicInventoryCurrencyGetParams) -> Result<models::CurrencyContentResponse, Error<BasicInventoryCurrencyGetError>> {

    let uri_str = format!("{}/basic/inventory/currency", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CurrencyContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CurrencyContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicInventoryCurrencyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_inventory_items_get(configuration: &configuration::Configuration, params: BasicInventoryItemsGetParams) -> Result<models::ItemContentResponse, Error<BasicInventoryItemsGetError>> {

    let uri_str = format!("{}/basic/inventory/items", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ItemContentResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ItemContentResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicInventoryItemsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_leaderboards_assignment_get(configuration: &configuration::Configuration, params: BasicLeaderboardsAssignmentGetParams) -> Result<models::LeaderboardAssignmentInfo, Error<BasicLeaderboardsAssignmentGetError>> {

    let uri_str = format!("{}/basic/leaderboards/assignment", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("boardId", &params.board_id.to_string())]);
    if let Some(ref param_value) = params.join_board {
        req_builder = req_builder.query(&[("joinBoard", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardAssignmentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardAssignmentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicLeaderboardsAssignmentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_leaderboards_list_get(configuration: &configuration::Configuration, params: BasicLeaderboardsListGetParams) -> Result<models::LeaderboardListResponse, Error<BasicLeaderboardsListGetError>> {

    let uri_str = format!("{}/basic/leaderboards/list", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prefix {
        req_builder = req_builder.query(&[("prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_partitions {
        req_builder = req_builder.query(&[("includePartitions", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicLeaderboardsListGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_leaderboards_player_get(configuration: &configuration::Configuration, params: BasicLeaderboardsPlayerGetParams) -> Result<models::ListLeaderBoardViewResponse, Error<BasicLeaderboardsPlayerGetError>> {

    let uri_str = format!("{}/basic/leaderboards/player", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("dbid", &params.dbid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListLeaderBoardViewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListLeaderBoardViewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicLeaderboardsPlayerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_leaderboards_uid_get(configuration: &configuration::Configuration, params: BasicLeaderboardsUidGetParams) -> Result<models::LeaderboardUidResponse, Error<BasicLeaderboardsUidGetError>> {

    let uri_str = format!("{}/basic/leaderboards/uid", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardUidResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardUidResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicLeaderboardsUidGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_mail_attachments_put(configuration: &configuration::Configuration, params: BasicMailAttachmentsPutParams) -> Result<models::MailSuccessResponse, Error<BasicMailAttachmentsPutError>> {

    let uri_str = format!("{}/basic/mail/attachments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.accept_multiple_attachments);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicMailAttachmentsPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_mail_bulk_post(configuration: &configuration::Configuration, params: BasicMailBulkPostParams) -> Result<models::MailSuccessResponse, Error<BasicMailBulkPostError>> {

    let uri_str = format!("{}/basic/mail/bulk", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.bulk_send_mail_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicMailBulkPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_mail_get(configuration: &configuration::Configuration, params: BasicMailGetParams) -> Result<models::MailResponse, Error<BasicMailGetError>> {

    let uri_str = format!("{}/basic/mail/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("mid", &params.mid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicMailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_mail_put(configuration: &configuration::Configuration, params: BasicMailPutParams) -> Result<models::MailSuccessResponse, Error<BasicMailPutError>> {

    let uri_str = format!("{}/basic/mail/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_mail_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicMailPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_mail_template_get(configuration: &configuration::Configuration, params: BasicMailTemplateGetParams) -> Result<models::MailTemplate, Error<BasicMailTemplateGetError>> {

    let uri_str = format!("{}/basic/mail/template", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("templateName", &params.template_name.to_string())]);
    req_builder = req_builder.query(&[("gamerTag", &params.gamer_tag.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailTemplate`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailTemplate`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicMailTemplateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_channel_post(configuration: &configuration::Configuration, params: BasicNotificationChannelPostParams) -> Result<models::CommonResponse, Error<BasicNotificationChannelPostError>> {

    let uri_str = format!("{}/basic/notification/channel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationChannelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_custom_post(configuration: &configuration::Configuration, params: BasicNotificationCustomPostParams) -> Result<models::CommonResponse, Error<BasicNotificationCustomPostError>> {

    let uri_str = format!("{}/basic/notification/custom", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationCustomPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_game_post(configuration: &configuration::Configuration, params: BasicNotificationGamePostParams) -> Result<models::CommonResponse, Error<BasicNotificationGamePostError>> {

    let uri_str = format!("{}/basic/notification/game", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationGamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_generic_post(configuration: &configuration::Configuration, params: BasicNotificationGenericPostParams) -> Result<models::CommonResponse, Error<BasicNotificationGenericPostError>> {

    let uri_str = format!("{}/basic/notification/generic", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationGenericPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_get(configuration: &configuration::Configuration, params: BasicNotificationGetParams) -> Result<models::SubscriberDetailsResponse, Error<BasicNotificationGetError>> {

    let uri_str = format!("{}/basic/notification/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubscriberDetailsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubscriberDetailsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_player_post(configuration: &configuration::Configuration, params: BasicNotificationPlayerPostParams) -> Result<models::CommonResponse, Error<BasicNotificationPlayerPostError>> {

    let uri_str = format!("{}/basic/notification/player", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationPlayerPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_notification_server_post(configuration: &configuration::Configuration, params: BasicNotificationServerPostParams) -> Result<models::CommonResponse, Error<BasicNotificationServerPostError>> {

    let uri_str = format!("{}/basic/notification/server", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.server_event);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicNotificationServerPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_audits_get(configuration: &configuration::Configuration, params: BasicPaymentsAuditsGetParams) -> Result<models::ListAuditResponse, Error<BasicPaymentsAuditsGetError>> {

    let uri_str = format!("{}/basic/payments/audits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.providerid {
        req_builder = req_builder.query(&[("providerid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.provider {
        req_builder = req_builder.query(&[("provider", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.txid {
        req_builder = req_builder.query(&[("txid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.player {
        req_builder = req_builder.query(&[("player", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListAuditResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListAuditResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsAuditsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_product_get(configuration: &configuration::Configuration, params: BasicPaymentsCouponProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsCouponProductGetError>> {

    let uri_str = format!("{}/basic/payments/coupon/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsCouponPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/coupon/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/coupon/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/coupon/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/coupon/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/coupon/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_coupon_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsCouponPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsCouponPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/coupon/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsCouponPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_product_get(configuration: &configuration::Configuration, params: BasicPaymentsFacebookProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsFacebookProductGetError>> {

    let uri_str = format!("{}/basic/payments/facebook/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsFacebookPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/facebook/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/facebook/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/facebook/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/facebook/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/facebook/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsFacebookPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/facebook/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_update_get(configuration: &configuration::Configuration, params: BasicPaymentsFacebookUpdateGetParams) -> Result<models::SubscriptionVerificationResponse, Error<BasicPaymentsFacebookUpdateGetError>> {

    let uri_str = format!("{}/basic/payments/facebook/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("hubMode", &params.hub_mode.to_string())]);
    req_builder = req_builder.query(&[("hubChallenge", &params.hub_challenge.to_string())]);
    req_builder = req_builder.query(&[("hubVerifyToken", &params.hub_verify_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SubscriptionVerificationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SubscriptionVerificationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookUpdateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_facebook_update_post(configuration: &configuration::Configuration, params: BasicPaymentsFacebookUpdatePostParams) -> Result<models::FacebookPaymentUpdateResponse, Error<BasicPaymentsFacebookUpdatePostError>> {

    let uri_str = format!("{}/basic/payments/facebook/update", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.facebook_payment_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FacebookPaymentUpdateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FacebookPaymentUpdateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsFacebookUpdatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_product_get(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsGoogleplayProductGetError>> {

    let uri_str = format!("{}/basic/payments/googleplay/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsGoogleplayPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/googleplay/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/googleplay/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/googleplay/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/googleplay/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/googleplay/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_googleplay_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsGoogleplayPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsGoogleplayPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/googleplay/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsGoogleplayPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_product_get(configuration: &configuration::Configuration, params: BasicPaymentsItunesProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsItunesProductGetError>> {

    let uri_str = format!("{}/basic/payments/itunes/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsItunesPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/itunes/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/itunes/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/itunes/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/itunes/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/itunes/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_itunes_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsItunesPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsItunesPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/itunes/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsItunesPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_auth_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamAuthPostParams) -> Result<models::EmptyResponse, Error<BasicPaymentsSteamAuthPostError>> {

    let uri_str = format!("{}/basic/payments/steam/auth", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.steam_auth_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamAuthPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_order_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamOrderGetParams) -> Result<models::SteamOrderInfoResponse, Error<BasicPaymentsSteamOrderGetError>> {

    let uri_str = format!("{}/basic/payments/steam/order", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("orderId", &params.order_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SteamOrderInfoResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SteamOrderInfoResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamOrderGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_prices_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamPricesGetParams) -> Result<models::LocalizedPriceMap, Error<BasicPaymentsSteamPricesGetError>> {

    let uri_str = format!("{}/basic/payments/steam/prices", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("steamId", &params.steam_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LocalizedPriceMap`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LocalizedPriceMap`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPricesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_product_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsSteamProductGetError>> {

    let uri_str = format!("{}/basic/payments/steam/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_products_get(configuration: &configuration::Configuration, params: BasicPaymentsSteamProductsGetParams) -> Result<models::GetProductsResponse, Error<BasicPaymentsSteamProductsGetError>> {

    let uri_str = format!("{}/basic/payments/steam/products", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("steamId", &params.steam_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamProductsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsSteamPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/steam/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/steam/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/steam/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/steam/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/steam/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_steam_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsSteamPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsSteamPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/steam/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsSteamPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_product_get(configuration: &configuration::Configuration, params: BasicPaymentsTestProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsTestProductGetError>> {

    let uri_str = format!("{}/basic/payments/test/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsTestPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/test/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/test/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/test/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/test/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/test/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_test_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsTestPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsTestPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/test/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsTestPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_product_get(configuration: &configuration::Configuration, params: BasicPaymentsWindowsProductGetParams) -> Result<models::GetProductResponse, Error<BasicPaymentsWindowsProductGetError>> {

    let uri_str = format!("{}/basic/payments/windows/product", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sku", &params.sku.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetProductResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetProductResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsProductGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_purchase_begin_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseBeginPostParams) -> Result<models::BeginPurchaseResponse, Error<BasicPaymentsWindowsPurchaseBeginPostError>> {

    let uri_str = format!("{}/basic/payments/windows/purchase/begin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.begin_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BeginPurchaseResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BeginPurchaseResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsPurchaseBeginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_purchase_cancel_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseCancelPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseCancelPostError>> {

    let uri_str = format!("{}/basic/payments/windows/purchase/cancel", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cancel_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsPurchaseCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_purchase_complete_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseCompletePostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseCompletePostError>> {

    let uri_str = format!("{}/basic/payments/windows/purchase/complete", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.complete_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsPurchaseCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_purchase_fail_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseFailPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseFailPostError>> {

    let uri_str = format!("{}/basic/payments/windows/purchase/fail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.fail_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsPurchaseFailPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_purchase_track_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseTrackPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseTrackPostError>> {

    let uri_str = format!("{}/basic/payments/windows/purchase/track", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.track_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsPurchaseTrackPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_payments_windows_purchase_verify_post(configuration: &configuration::Configuration, params: BasicPaymentsWindowsPurchaseVerifyPostParams) -> Result<models::PaymentResultResponse, Error<BasicPaymentsWindowsPurchaseVerifyPostError>> {

    let uri_str = format!("{}/basic/payments/windows/purchase/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.verify_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaymentResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaymentResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPaymentsWindowsPurchaseVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_push_register_post(configuration: &configuration::Configuration, params: BasicPushRegisterPostParams) -> Result<serde_json::Value, Error<BasicPushRegisterPostError>> {

    let uri_str = format!("{}/basic/push/register", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.register_req);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPushRegisterPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_push_send_post(configuration: &configuration::Configuration, params: BasicPushSendPostParams) -> Result<serde_json::Value, Error<BasicPushSendPostError>> {

    let uri_str = format!("{}/basic/push/send", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.send_req);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicPushSendPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_admin_customer_get(configuration: &configuration::Configuration, params: BasicRealmsAdminCustomerGetParams) -> Result<models::CustomerResponse, Error<BasicRealmsAdminCustomerGetError>> {

    let uri_str = format!("{}/basic/realms/admin/customer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsAdminCustomerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_admin_inflight_failures_delete(configuration: &configuration::Configuration, params: BasicRealmsAdminInflightFailuresDeleteParams) -> Result<models::CommonResponse, Error<BasicRealmsAdminInflightFailuresDeleteError>> {

    let uri_str = format!("{}/basic/realms/admin/inflight/failures", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.batch_delete_in_flight_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsAdminInflightFailuresDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_admin_inflight_failures_get(configuration: &configuration::Configuration, params: BasicRealmsAdminInflightFailuresGetParams) -> Result<models::InFlightFailureResponse, Error<BasicRealmsAdminInflightFailuresGetError>> {

    let uri_str = format!("{}/basic/realms/admin/inflight/failures", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.service_object_id {
        req_builder = req_builder.query(&[("serviceObjectId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("serviceName", &params.service_name.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InFlightFailureResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InFlightFailureResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsAdminInflightFailuresGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_client_defaults_get(configuration: &configuration::Configuration, params: BasicRealmsClientDefaultsGetParams) -> Result<models::RealmConfiguration, Error<BasicRealmsClientDefaultsGetError>> {

    let uri_str = format!("{}/basic/realms/client/defaults", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RealmConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RealmConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsClientDefaultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_config_get(configuration: &configuration::Configuration, params: BasicRealmsConfigGetParams) -> Result<models::RealmConfigResponse, Error<BasicRealmsConfigGetError>> {

    let uri_str = format!("{}/basic/realms/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RealmConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RealmConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_config_post(configuration: &configuration::Configuration, params: BasicRealmsConfigPostParams) -> Result<models::CommonResponse, Error<BasicRealmsConfigPostError>> {

    let uri_str = format!("{}/basic/realms/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.realm_config_change_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsConfigPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_config_put(configuration: &configuration::Configuration, params: BasicRealmsConfigPutParams) -> Result<models::CommonResponse, Error<BasicRealmsConfigPutError>> {

    let uri_str = format!("{}/basic/realms/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.realm_config_save_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsConfigPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_customer_activate_get(configuration: &configuration::Configuration, params: BasicRealmsCustomerActivateGetParams) -> Result<models::HtmlResponse, Error<BasicRealmsCustomerActivateGetError>> {

    let uri_str = format!("{}/basic/realms/customer/activate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("token", &params.token.to_string())]);
    req_builder = req_builder.query(&[("cid", &params.cid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::HtmlResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::HtmlResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsCustomerActivateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_customer_alias_available_get(configuration: &configuration::Configuration, params: BasicRealmsCustomerAliasAvailableGetParams) -> Result<models::AliasAvailableResponse, Error<BasicRealmsCustomerAliasAvailableGetError>> {

    let uri_str = format!("{}/basic/realms/customer/alias/available", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("alias", &params.alias.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AliasAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AliasAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsCustomerAliasAvailableGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_customer_get(configuration: &configuration::Configuration, params: BasicRealmsCustomerGetParams) -> Result<models::CustomerViewResponse, Error<BasicRealmsCustomerGetError>> {

    let uri_str = format!("{}/basic/realms/customer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerViewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerViewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsCustomerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_customer_post(configuration: &configuration::Configuration, params: BasicRealmsCustomerPostParams) -> Result<models::NewCustomerResponse, Error<BasicRealmsCustomerPostError>> {

    let uri_str = format!("{}/basic/realms/customer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.new_customer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NewCustomerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NewCustomerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsCustomerPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_customer_verify_post(configuration: &configuration::Configuration, params: BasicRealmsCustomerVerifyPostParams) -> Result<models::NewCustomerResponse, Error<BasicRealmsCustomerVerifyPostError>> {

    let uri_str = format!("{}/basic/realms/customer/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.new_customer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NewCustomerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NewCustomerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsCustomerVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_customers_get(configuration: &configuration::Configuration, params: BasicRealmsCustomersGetParams) -> Result<models::CustomersResponse, Error<BasicRealmsCustomersGetError>> {

    let uri_str = format!("{}/basic/realms/customers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsCustomersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_game_get(configuration: &configuration::Configuration, params: BasicRealmsGameGetParams) -> Result<models::GetGameResponse, Error<BasicRealmsGameGetError>> {

    let uri_str = format!("{}/basic/realms/game", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("rootPID", &params.root_pid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGameResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGameResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsGameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_game_post(configuration: &configuration::Configuration, params: BasicRealmsGamePostParams) -> Result<models::CommonResponse, Error<BasicRealmsGamePostError>> {

    let uri_str = format!("{}/basic/realms/game", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.new_game_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsGamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_game_put(configuration: &configuration::Configuration, params: BasicRealmsGamePutParams) -> Result<models::CommonResponse, Error<BasicRealmsGamePutError>> {

    let uri_str = format!("{}/basic/realms/game", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_game_hierarchy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsGamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_games_get(configuration: &configuration::Configuration, params: BasicRealmsGamesGetParams) -> Result<models::GetGameResponse, Error<BasicRealmsGamesGetError>> {

    let uri_str = format!("{}/basic/realms/games", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGameResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGameResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsGamesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_is_customer_get(configuration: &configuration::Configuration, params: BasicRealmsIsCustomerGetParams) -> Result<models::EmptyResponse, Error<BasicRealmsIsCustomerGetError>> {

    let uri_str = format!("{}/basic/realms/is-customer", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsIsCustomerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_launch_message_delete(configuration: &configuration::Configuration, params: BasicRealmsLaunchMessageDeleteParams) -> Result<models::CommonResponse, Error<BasicRealmsLaunchMessageDeleteError>> {

    let uri_str = format!("{}/basic/realms/launch-message", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.remove_launch_message_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsLaunchMessageDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_launch_message_get(configuration: &configuration::Configuration, params: BasicRealmsLaunchMessageGetParams) -> Result<models::LaunchMessageListResponse, Error<BasicRealmsLaunchMessageGetError>> {

    let uri_str = format!("{}/basic/realms/launch-message", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LaunchMessageListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LaunchMessageListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsLaunchMessageGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_launch_message_post(configuration: &configuration::Configuration, params: BasicRealmsLaunchMessagePostParams) -> Result<models::CommonResponse, Error<BasicRealmsLaunchMessagePostError>> {

    let uri_str = format!("{}/basic/realms/launch-message", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_launch_message_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsLaunchMessagePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_plans_get(configuration: &configuration::Configuration, params: BasicRealmsPlansGetParams) -> Result<models::ServicePlansResponse, Error<BasicRealmsPlansGetError>> {

    let uri_str = format!("{}/basic/realms/plans", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ServicePlansResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ServicePlansResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsPlansGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_plans_post(configuration: &configuration::Configuration, params: BasicRealmsPlansPostParams) -> Result<models::CommonResponse, Error<BasicRealmsPlansPostError>> {

    let uri_str = format!("{}/basic/realms/plans", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_plan_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsPlansPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_beamable_post(configuration: &configuration::Configuration, params: BasicRealmsProjectBeamablePostParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectBeamablePostError>> {

    let uri_str = format!("{}/basic/realms/project/beamable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectBeamablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_delete(configuration: &configuration::Configuration, params: BasicRealmsProjectDeleteParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectDeleteError>> {

    let uri_str = format!("{}/basic/realms/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.archive_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_get(configuration: &configuration::Configuration, params: BasicRealmsProjectGetParams) -> Result<models::ProjectView, Error<BasicRealmsProjectGetError>> {

    let uri_str = format!("{}/basic/realms/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProjectView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProjectView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_post(configuration: &configuration::Configuration, params: BasicRealmsProjectPostParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectPostError>> {

    let uri_str = format!("{}/basic/realms/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_promote_get(configuration: &configuration::Configuration, params: BasicRealmsProjectPromoteGetParams) -> Result<models::PromoteRealmResponseOld, Error<BasicRealmsProjectPromoteGetError>> {

    let uri_str = format!("{}/basic/realms/project/promote", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sourcePid", &params.source_pid.to_string())]);
    if let Some(ref param_value) = params.promotions {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("promotions".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("promotions", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.content_manifest_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("contentManifestIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("contentManifestIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PromoteRealmResponseOld`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PromoteRealmResponseOld`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectPromoteGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_promote_post(configuration: &configuration::Configuration, params: BasicRealmsProjectPromotePostParams) -> Result<models::PromoteRealmResponseOld, Error<BasicRealmsProjectPromotePostError>> {

    let uri_str = format!("{}/basic/realms/project/promote", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.promote_realm_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PromoteRealmResponseOld`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PromoteRealmResponseOld`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectPromotePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_put(configuration: &configuration::Configuration, params: BasicRealmsProjectPutParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectPutError>> {

    let uri_str = format!("{}/basic/realms/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.unarchive_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_project_rename_put(configuration: &configuration::Configuration, params: BasicRealmsProjectRenamePutParams) -> Result<models::CommonResponse, Error<BasicRealmsProjectRenamePutError>> {

    let uri_str = format!("{}/basic/realms/project/rename", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.rename_project_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsProjectRenamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_promotion_get(configuration: &configuration::Configuration, params: BasicRealmsPromotionGetParams) -> Result<models::PromoteRealmResponse, Error<BasicRealmsPromotionGetError>> {

    let uri_str = format!("{}/basic/realms/promotion", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sourcePid", &params.source_pid.to_string())]);
    if let Some(ref param_value) = params.promotions {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("promotions".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("promotions", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.content_manifest_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("contentManifestIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("contentManifestIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PromoteRealmResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PromoteRealmResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsPromotionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_realms_promotion_post(configuration: &configuration::Configuration, params: BasicRealmsPromotionPostParams) -> Result<models::PromoteRealmResponse, Error<BasicRealmsPromotionPostError>> {

    let uri_str = format!("{}/basic/realms/promotion", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.promote_realm_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PromoteRealmResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PromoteRealmResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicRealmsPromotionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_session_client_history_get(configuration: &configuration::Configuration, params: BasicSessionClientHistoryGetParams) -> Result<models::SessionClientHistoryResponse, Error<BasicSessionClientHistoryGetError>> {

    let uri_str = format!("{}/basic/session/client/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.month {
        req_builder = req_builder.query(&[("month", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.year {
        req_builder = req_builder.query(&[("year", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionClientHistoryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionClientHistoryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSessionClientHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_session_heartbeat_post(configuration: &configuration::Configuration, params: BasicSessionHeartbeatPostParams) -> Result<models::SessionHeartbeat, Error<BasicSessionHeartbeatPostError>> {

    let uri_str = format!("{}/basic/session/heartbeat", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionHeartbeat`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionHeartbeat`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSessionHeartbeatPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_session_history_get(configuration: &configuration::Configuration, params: BasicSessionHistoryGetParams) -> Result<models::SessionHistoryResponse, Error<BasicSessionHistoryGetError>> {

    let uri_str = format!("{}/basic/session/history", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("dbid", &params.dbid.to_string())]);
    if let Some(ref param_value) = params.month {
        req_builder = req_builder.query(&[("month", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.year {
        req_builder = req_builder.query(&[("year", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionHistoryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionHistoryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSessionHistoryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_session_post(configuration: &configuration::Configuration, params: BasicSessionPostParams) -> Result<models::StartSessionResponse, Error<BasicSessionPostError>> {

    let uri_str = format!("{}/basic/session/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.start_session_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StartSessionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StartSessionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSessionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_session_status_get(configuration: &configuration::Configuration, params: BasicSessionStatusGetParams) -> Result<models::OnlineStatusResponses, Error<BasicSessionStatusGetError>> {

    let uri_str = format!("{}/basic/session/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("playerIds", &params.player_ids.to_string())]);
    req_builder = req_builder.query(&[("intervalSecs", &params.interval_secs.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OnlineStatusResponses`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OnlineStatusResponses`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSessionStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_blocked_delete(configuration: &configuration::Configuration, params: BasicSocialBlockedDeleteParams) -> Result<models::FriendshipStatus, Error<BasicSocialBlockedDeleteError>> {

    let uri_str = format!("{}/basic/social/blocked", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.player_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FriendshipStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FriendshipStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialBlockedDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_blocked_post(configuration: &configuration::Configuration, params: BasicSocialBlockedPostParams) -> Result<models::FriendshipStatus, Error<BasicSocialBlockedPostError>> {

    let uri_str = format!("{}/basic/social/blocked", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.player_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FriendshipStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FriendshipStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialBlockedPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_friends_delete(configuration: &configuration::Configuration, params: BasicSocialFriendsDeleteParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsDeleteError>> {

    let uri_str = format!("{}/basic/social/friends", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.player_id_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialFriendsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_friends_import_post(configuration: &configuration::Configuration, params: BasicSocialFriendsImportPostParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsImportPostError>> {

    let uri_str = format!("{}/basic/social/friends/import", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.import_friends_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialFriendsImportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_friends_invite_delete(configuration: &configuration::Configuration, params: BasicSocialFriendsInviteDeleteParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsInviteDeleteError>> {

    let uri_str = format!("{}/basic/social/friends/invite", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.send_friend_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialFriendsInviteDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_friends_invite_post(configuration: &configuration::Configuration, params: BasicSocialFriendsInvitePostParams) -> Result<models::EmptyResponse, Error<BasicSocialFriendsInvitePostError>> {

    let uri_str = format!("{}/basic/social/friends/invite", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.send_friend_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialFriendsInvitePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_friends_make_post(configuration: &configuration::Configuration, params: BasicSocialFriendsMakePostParams) -> Result<models::CommonResponse, Error<BasicSocialFriendsMakePostError>> {

    let uri_str = format!("{}/basic/social/friends/make", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.make_friendship_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialFriendsMakePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_get(configuration: &configuration::Configuration, params: BasicSocialGetParams) -> Result<models::GetSocialStatusesResponse, Error<BasicSocialGetError>> {

    let uri_str = format!("{}/basic/social/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&params.player_ids.into_iter().map(|p| ("playerIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("playerIds", &params.player_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetSocialStatusesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetSocialStatusesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_social_my_get(configuration: &configuration::Configuration, params: BasicSocialMyGetParams) -> Result<models::Social, Error<BasicSocialMyGetError>> {

    let uri_str = format!("{}/basic/social/my", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Social`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Social`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicSocialMyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_stats_batch_post(configuration: &configuration::Configuration, params: BasicStatsBatchPostParams) -> Result<models::EmptyResponse, Error<BasicStatsBatchPostError>> {

    let uri_str = format!("{}/basic/stats/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.batch_set_stats_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicStatsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_stats_client_batch_get(configuration: &configuration::Configuration, params: BasicStatsClientBatchGetParams) -> Result<models::BatchReadStatsResponse, Error<BasicStatsClientBatchGetError>> {

    let uri_str = format!("{}/basic/stats/client/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("objectIds", &params.object_ids.to_string())]);
    if let Some(ref param_value) = params.stats {
        req_builder = req_builder.query(&[("stats", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BatchReadStatsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BatchReadStatsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicStatsClientBatchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_stats_search_extended_post(configuration: &configuration::Configuration, params: BasicStatsSearchExtendedPostParams) -> Result<models::SearchExtendedResponse, Error<BasicStatsSearchExtendedPostError>> {

    let uri_str = format!("{}/basic/stats/search/extended", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.search_extended_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SearchExtendedResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SearchExtendedResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicStatsSearchExtendedPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_stats_search_post(configuration: &configuration::Configuration, params: BasicStatsSearchPostParams) -> Result<models::StatsSearchResponse, Error<BasicStatsSearchPostError>> {

    let uri_str = format!("{}/basic/stats/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stats_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicStatsSearchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_stats_subscribe_delete(configuration: &configuration::Configuration, params: BasicStatsSubscribeDeleteParams) -> Result<models::CommonResponse, Error<BasicStatsSubscribeDeleteError>> {

    let uri_str = format!("{}/basic/stats/subscribe", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stats_unsubscribe_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicStatsSubscribeDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_stats_subscribe_put(configuration: &configuration::Configuration, params: BasicStatsSubscribePutParams) -> Result<models::CommonResponse, Error<BasicStatsSubscribePutError>> {

    let uri_str = format!("{}/basic/stats/subscribe", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stats_subscribe_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicStatsSubscribePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_admin_player_get(configuration: &configuration::Configuration, params: BasicTournamentsAdminPlayerGetParams) -> Result<models::AdminGetPlayerStatusResponse, Error<BasicTournamentsAdminPlayerGetError>> {

    let uri_str = format!("{}/basic/tournaments/admin/player", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("playerId", &params.player_id.to_string())]);
    if let Some(ref param_value) = params.tournament_id {
        req_builder = req_builder.query(&[("tournamentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.has_unclaimed_rewards {
        req_builder = req_builder.query(&[("hasUnclaimedRewards", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AdminGetPlayerStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AdminGetPlayerStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsAdminPlayerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_admin_player_put(configuration: &configuration::Configuration, params: BasicTournamentsAdminPlayerPutParams) -> Result<models::AdminPlayerStatus, Error<BasicTournamentsAdminPlayerPutError>> {

    let uri_str = format!("{}/basic/tournaments/admin/player", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_player_status_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AdminPlayerStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AdminPlayerStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsAdminPlayerPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_champions_get(configuration: &configuration::Configuration, params: BasicTournamentsChampionsGetParams) -> Result<models::GetChampionsResponse, Error<BasicTournamentsChampionsGetError>> {

    let uri_str = format!("{}/basic/tournaments/champions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tournamentId", &params.tournament_id.to_string())]);
    req_builder = req_builder.query(&[("cycles", &params.cycles.to_string())]);
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetChampionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetChampionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsChampionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_get(configuration: &configuration::Configuration, params: BasicTournamentsGetParams) -> Result<models::TournamentQueryResponse, Error<BasicTournamentsGetError>> {

    let uri_str = format!("{}/basic/tournaments/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.is_running {
        req_builder = req_builder.query(&[("isRunning", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cycle {
        req_builder = req_builder.query(&[("cycle", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TournamentQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TournamentQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_global_get(configuration: &configuration::Configuration, params: BasicTournamentsGlobalGetParams) -> Result<models::GetStandingsResponse, Error<BasicTournamentsGlobalGetError>> {

    let uri_str = format!("{}/basic/tournaments/global", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tournamentId", &params.tournament_id.to_string())]);
    if let Some(ref param_value) = params.max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.focus {
        req_builder = req_builder.query(&[("focus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cycle {
        req_builder = req_builder.query(&[("cycle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetStandingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetStandingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsGlobalGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_groups_get(configuration: &configuration::Configuration, params: BasicTournamentsGroupsGetParams) -> Result<models::GetGroupsResponse, Error<BasicTournamentsGroupsGetError>> {

    let uri_str = format!("{}/basic/tournaments/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tournamentId", &params.tournament_id.to_string())]);
    if let Some(ref param_value) = params.max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.focus {
        req_builder = req_builder.query(&[("focus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cycle {
        req_builder = req_builder.query(&[("cycle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGroupsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGroupsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsGroupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_me_get(configuration: &configuration::Configuration, params: BasicTournamentsMeGetParams) -> Result<models::GetPlayerStatusResponse, Error<BasicTournamentsMeGetError>> {

    let uri_str = format!("{}/basic/tournaments/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.tournament_id {
        req_builder = req_builder.query(&[("tournamentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.has_unclaimed_rewards {
        req_builder = req_builder.query(&[("hasUnclaimedRewards", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPlayerStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPlayerStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsMeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_me_group_get(configuration: &configuration::Configuration, params: BasicTournamentsMeGroupGetParams) -> Result<models::GetGroupStatusResponse, Error<BasicTournamentsMeGroupGetError>> {

    let uri_str = format!("{}/basic/tournaments/me/group", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGroupStatusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGroupStatusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsMeGroupGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_post(configuration: &configuration::Configuration, params: BasicTournamentsPostParams) -> Result<models::PlayerStatus, Error<BasicTournamentsPostError>> {

    let uri_str = format!("{}/basic/tournaments/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.join_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlayerStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlayerStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_rewards_get(configuration: &configuration::Configuration, params: BasicTournamentsRewardsGetParams) -> Result<models::RewardsResponse, Error<BasicTournamentsRewardsGetError>> {

    let uri_str = format!("{}/basic/tournaments/rewards", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.tournament_id {
        req_builder = req_builder.query(&[("tournamentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RewardsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RewardsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsRewardsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_rewards_post(configuration: &configuration::Configuration, params: BasicTournamentsRewardsPostParams) -> Result<models::RewardsResponse, Error<BasicTournamentsRewardsPostError>> {

    let uri_str = format!("{}/basic/tournaments/rewards", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.rewards_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RewardsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RewardsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsRewardsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_score_post(configuration: &configuration::Configuration, params: BasicTournamentsScorePostParams) -> Result<models::EmptyResponse, Error<BasicTournamentsScorePostError>> {

    let uri_str = format!("{}/basic/tournaments/score", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.score_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsScorePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_search_groups_post(configuration: &configuration::Configuration, params: BasicTournamentsSearchGroupsPostParams) -> Result<models::GetStatusForGroupsResponse, Error<BasicTournamentsSearchGroupsPostError>> {

    let uri_str = format!("{}/basic/tournaments/search/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.get_status_for_groups_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetStatusForGroupsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetStatusForGroupsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsSearchGroupsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_standings_get(configuration: &configuration::Configuration, params: BasicTournamentsStandingsGetParams) -> Result<models::GetStandingsResponse, Error<BasicTournamentsStandingsGetError>> {

    let uri_str = format!("{}/basic/tournaments/standings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tournamentId", &params.tournament_id.to_string())]);
    if let Some(ref param_value) = params.max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.focus {
        req_builder = req_builder.query(&[("focus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cycle {
        req_builder = req_builder.query(&[("cycle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetStandingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetStandingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsStandingsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_tournaments_standings_group_get(configuration: &configuration::Configuration, params: BasicTournamentsStandingsGroupGetParams) -> Result<models::GetStandingsResponse, Error<BasicTournamentsStandingsGroupGetError>> {

    let uri_str = format!("{}/basic/tournaments/standings/group", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tournamentId", &params.tournament_id.to_string())]);
    if let Some(ref param_value) = params.max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.focus {
        req_builder = req_builder.query(&[("focus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cycle {
        req_builder = req_builder.query(&[("cycle", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_id {
        req_builder = req_builder.query(&[("contentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetStandingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetStandingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTournamentsStandingsGroupGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_admin_data_get(configuration: &configuration::Configuration, params: BasicTrialsAdminDataGetParams) -> Result<models::GetS3DataResponse, Error<BasicTrialsAdminDataGetError>> {

    let uri_str = format!("{}/basic/trials/admin/data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &params.id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetS3DataResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetS3DataResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsAdminDataGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_admin_get(configuration: &configuration::Configuration, params: BasicTrialsAdminGetParams) -> Result<models::GetPlayerTrialsResponse, Error<BasicTrialsAdminGetError>> {

    let uri_str = format!("{}/basic/trials/admin", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("dbid", &params.dbid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetPlayerTrialsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetPlayerTrialsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsAdminGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_data_delete(configuration: &configuration::Configuration, params: BasicTrialsDataDeleteParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsDataDeleteError>> {

    let uri_str = format!("{}/basic/trials/data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_trial_data_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrialSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrialSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsDataDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_data_post(configuration: &configuration::Configuration, params: BasicTrialsDataPostParams) -> Result<models::SaveGameDataResponse, Error<BasicTrialsDataPostError>> {

    let uri_str = format!("{}/basic/trials/data", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.upload_trial_data_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SaveGameDataResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SaveGameDataResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsDataPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_delete(configuration: &configuration::Configuration, params: BasicTrialsDeleteParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsDeleteError>> {

    let uri_str = format!("{}/basic/trials/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_trial_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrialSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrialSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_get(configuration: &configuration::Configuration, params: BasicTrialsGetParams) -> Result<models::ListTrialsResponse, Error<BasicTrialsGetError>> {

    let uri_str = format!("{}/basic/trials/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListTrialsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListTrialsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_pause_put(configuration: &configuration::Configuration, params: BasicTrialsPausePutParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsPausePutError>> {

    let uri_str = format!("{}/basic/trials/pause", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.pause_trial_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrialSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrialSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsPausePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_post(configuration: &configuration::Configuration, params: BasicTrialsPostParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsPostError>> {

    let uri_str = format!("{}/basic/trials/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_trial_rest_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrialSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrialSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_schedule_put(configuration: &configuration::Configuration, params: BasicTrialsSchedulePutParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsSchedulePutError>> {

    let uri_str = format!("{}/basic/trials/schedule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.schedule_trial_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrialSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrialSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsSchedulePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn basic_trials_start_put(configuration: &configuration::Configuration, params: BasicTrialsStartPutParams) -> Result<models::TrialSuccessResponse, Error<BasicTrialsStartPutError>> {

    let uri_str = format!("{}/basic/trials/start", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.start_trial_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TrialSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TrialSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BasicTrialsStartPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_admin_email_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminEmailPutParams) -> Result<models::Account, Error<ObjectAccountsObjectIdAdminEmailPutError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/admin/email", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.email_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Account`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Account`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAdminEmailPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_admin_forget_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminForgetDeleteParams) -> Result<models::Account, Error<ObjectAccountsObjectIdAdminForgetDeleteError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/admin/forget", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Account`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Account`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAdminForgetDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_admin_scope_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminScopeDeleteParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminScopeDeleteError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/admin/scope", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAdminScopeDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_admin_scope_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminScopePutParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminScopePutError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/admin/scope", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAdminScopePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_admin_third_party_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminThirdPartyDeleteParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminThirdPartyDeleteError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/admin/third-party", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_third_party_association);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAdminThirdPartyDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_admin_third_party_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAdminThirdPartyPutParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdAdminThirdPartyPutError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/admin/third-party", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.transfer_third_party_association);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAdminThirdPartyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_available_roles_get(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdAvailableRolesGetParams) -> Result<models::AvailableRolesResponse, Error<ObjectAccountsObjectIdAvailableRolesGetError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/available-roles", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvailableRolesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvailableRolesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdAvailableRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdPutParams) -> Result<models::Account, Error<ObjectAccountsObjectIdPutError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.account_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Account`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Account`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_role_delete(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdRoleDeleteParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdRoleDeleteError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/role", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdRoleDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_role_put(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdRolePutParams) -> Result<models::EmptyResponse, Error<ObjectAccountsObjectIdRolePutError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/role", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_role);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdRolePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_accounts_object_id_role_report_get(configuration: &configuration::Configuration, params: ObjectAccountsObjectIdRoleReportGetParams) -> Result<models::AccountRolesReport, Error<ObjectAccountsObjectIdRoleReportGetError>> {

    let uri_str = format!("{}/object/accounts/{objectId}/role/report", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AccountRolesReport`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AccountRolesReport`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAccountsObjectIdRoleReportGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_announcements_object_id_claim_post(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdClaimPostParams) -> Result<models::CommonResponse, Error<ObjectAnnouncementsObjectIdClaimPostError>> {

    let uri_str = format!("{}/object/announcements/{objectId}/claim", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.announcement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAnnouncementsObjectIdClaimPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_announcements_object_id_delete(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdDeleteParams) -> Result<models::CommonResponse, Error<ObjectAnnouncementsObjectIdDeleteError>> {

    let uri_str = format!("{}/object/announcements/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.announcement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAnnouncementsObjectIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_announcements_object_id_get(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdGetParams) -> Result<models::AnnouncementQueryResponse, Error<ObjectAnnouncementsObjectIdGetError>> {

    let uri_str = format!("{}/object/announcements/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.include_deleted {
        req_builder = req_builder.query(&[("include_deleted", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AnnouncementQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AnnouncementQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAnnouncementsObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_announcements_object_id_raw_get(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdRawGetParams) -> Result<models::AnnouncementRawResponse, Error<ObjectAnnouncementsObjectIdRawGetError>> {

    let uri_str = format!("{}/object/announcements/{objectId}/raw", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AnnouncementRawResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AnnouncementRawResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAnnouncementsObjectIdRawGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_announcements_object_id_read_put(configuration: &configuration::Configuration, params: ObjectAnnouncementsObjectIdReadPutParams) -> Result<models::CommonResponse, Error<ObjectAnnouncementsObjectIdReadPutError>> {

    let uri_str = format!("{}/object/announcements/{objectId}/read", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.announcement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectAnnouncementsObjectIdReadPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_calendars_object_id_claim_post(configuration: &configuration::Configuration, params: ObjectCalendarsObjectIdClaimPostParams) -> Result<models::CommonResponse, Error<ObjectCalendarsObjectIdClaimPostError>> {

    let uri_str = format!("{}/object/calendars/{objectId}/claim", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.calendar_claim_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCalendarsObjectIdClaimPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_calendars_object_id_get(configuration: &configuration::Configuration, params: ObjectCalendarsObjectIdGetParams) -> Result<models::CalendarQueryResponse, Error<ObjectCalendarsObjectIdGetError>> {

    let uri_str = format!("{}/object/calendars/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CalendarQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CalendarQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCalendarsObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_chat_v2_object_id_get(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdGetParams) -> Result<models::GetRoomsResponse, Error<ObjectChatV2ObjectIdGetError>> {

    let uri_str = format!("{}/object/chatV2/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetRoomsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetRoomsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectChatV2ObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_chat_v2_object_id_messages_post(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdMessagesPostParams) -> Result<models::SendMessageResponse, Error<ObjectChatV2ObjectIdMessagesPostError>> {

    let uri_str = format!("{}/object/chatV2/{objectId}/messages", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.send_message_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SendMessageResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SendMessageResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectChatV2ObjectIdMessagesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_chat_v2_object_id_rooms_delete(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdRoomsDeleteParams) -> Result<models::LeaveRoomResponse, Error<ObjectChatV2ObjectIdRoomsDeleteError>> {

    let uri_str = format!("{}/object/chatV2/{objectId}/rooms", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.leave_room_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaveRoomResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaveRoomResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectChatV2ObjectIdRoomsDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_chat_v2_object_id_rooms_get(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdRoomsGetParams) -> Result<models::GetRoomsResponse, Error<ObjectChatV2ObjectIdRoomsGetError>> {

    let uri_str = format!("{}/object/chatV2/{objectId}/rooms", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetRoomsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetRoomsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectChatV2ObjectIdRoomsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_chat_v2_object_id_rooms_post(configuration: &configuration::Configuration, params: ObjectChatV2ObjectIdRoomsPostParams) -> Result<models::CreateRoomResponse, Error<ObjectChatV2ObjectIdRoomsPostError>> {

    let uri_str = format!("{}/object/chatV2/{objectId}/rooms", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_room_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateRoomResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateRoomResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectChatV2ObjectIdRoomsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_coupons_count_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdCouponsCountGetParams) -> Result<models::GetTotalCouponResponse, Error<ObjectCommerceObjectIdCouponsCountGetError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/coupons/count", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetTotalCouponResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetTotalCouponResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdCouponsCountGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_coupons_post(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdCouponsPostParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdCouponsPostError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/coupons", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.give_coupon_req);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdCouponsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdGetParams) -> Result<models::GetActiveOffersResponse, Error<ObjectCommerceObjectIdGetError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetActiveOffersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetActiveOffersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_listings_cooldown_put(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdListingsCooldownPutParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdListingsCooldownPutError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/listings/cooldown", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.cooldown_modifier_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdListingsCooldownPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_listings_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdListingsGetParams) -> Result<models::ActiveListingResponse, Error<ObjectCommerceObjectIdListingsGetError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/listings", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("listing", &params.listing.to_string())]);
    if let Some(ref param_value) = params.store {
        req_builder = req_builder.query(&[("store", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ActiveListingResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ActiveListingResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdListingsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_offers_admin_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdOffersAdminGetParams) -> Result<models::GetActiveOffersResponse, Error<ObjectCommerceObjectIdOffersAdminGetError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/offersAdmin", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.stores {
        req_builder = req_builder.query(&[("stores", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetActiveOffersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetActiveOffersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdOffersAdminGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_offers_get(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdOffersGetParams) -> Result<models::GetActiveOffersResponse, Error<ObjectCommerceObjectIdOffersGetError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/offers", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.time {
        req_builder = req_builder.query(&[("time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.stores {
        req_builder = req_builder.query(&[("stores", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetActiveOffersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetActiveOffersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdOffersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_purchase_post(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdPurchasePostParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdPurchasePostError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/purchase", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdPurchasePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_purchase_put(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdPurchasePutParams) -> Result<models::ResultResponse, Error<ObjectCommerceObjectIdPurchasePutError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/purchase", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.report_purchase_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResultResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResultResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdPurchasePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_stats_update_post(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdStatsUpdatePostParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdStatsUpdatePostError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/stats/update", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stat_subscription_notification);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdStatsUpdatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_commerce_object_id_status_delete(configuration: &configuration::Configuration, params: ObjectCommerceObjectIdStatusDeleteParams) -> Result<models::CommonResponse, Error<ObjectCommerceObjectIdStatusDeleteError>> {

    let uri_str = format!("{}/object/commerce/{objectId}/status", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.clear_status_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectCommerceObjectIdStatusDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_event_players_object_id_claim_post(configuration: &configuration::Configuration, params: ObjectEventPlayersObjectIdClaimPostParams) -> Result<models::EventClaimResponse, Error<ObjectEventPlayersObjectIdClaimPostError>> {

    let uri_str = format!("{}/object/event-players/{objectId}/claim", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.event_claim_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventClaimResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventClaimResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventPlayersObjectIdClaimPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_event_players_object_id_get(configuration: &configuration::Configuration, params: ObjectEventPlayersObjectIdGetParams) -> Result<models::EventPlayerView, Error<ObjectEventPlayersObjectIdGetError>> {

    let uri_str = format!("{}/object/event-players/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventPlayerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventPlayerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventPlayersObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_event_players_object_id_score_put(configuration: &configuration::Configuration, params: ObjectEventPlayersObjectIdScorePutParams) -> Result<models::CommonResponse, Error<ObjectEventPlayersObjectIdScorePutError>> {

    let uri_str = format!("{}/object/event-players/{objectId}/score", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.event_score_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventPlayersObjectIdScorePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_events_object_id_content_delete(configuration: &configuration::Configuration, params: ObjectEventsObjectIdContentDeleteParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdContentDeleteError>> {

    let uri_str = format!("{}/object/events/{objectId}/content", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventsObjectIdContentDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_events_object_id_content_put(configuration: &configuration::Configuration, params: ObjectEventsObjectIdContentPutParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdContentPutError>> {

    let uri_str = format!("{}/object/events/{objectId}/content", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.set_content_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventsObjectIdContentPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_events_object_id_end_phase_put(configuration: &configuration::Configuration, params: ObjectEventsObjectIdEndPhasePutParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdEndPhasePutError>> {

    let uri_str = format!("{}/object/events/{objectId}/endPhase", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.event_phase_end_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventsObjectIdEndPhasePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_events_object_id_get(configuration: &configuration::Configuration, params: ObjectEventsObjectIdGetParams) -> Result<models::EventObjectData, Error<ObjectEventsObjectIdGetError>> {

    let uri_str = format!("{}/object/events/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventObjectData`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventObjectData`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventsObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_events_object_id_ping_get(configuration: &configuration::Configuration, params: ObjectEventsObjectIdPingGetParams) -> Result<models::PingRsp, Error<ObjectEventsObjectIdPingGetError>> {

    let uri_str = format!("{}/object/events/{objectId}/ping", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PingRsp`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PingRsp`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventsObjectIdPingGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_events_object_id_refresh_put(configuration: &configuration::Configuration, params: ObjectEventsObjectIdRefreshPutParams) -> Result<models::CommonResponse, Error<ObjectEventsObjectIdRefreshPutError>> {

    let uri_str = format!("{}/object/events/{objectId}/refresh", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectEventsObjectIdRefreshPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_availability_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdAvailabilityGetParams) -> Result<models::AvailabilityResponse, Error<ObjectGroupUsersObjectIdAvailabilityGetError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/availability", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tag {
        req_builder = req_builder.query(&[("tag", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("type", &params.r#type.to_string())]);
    if let Some(ref param_value) = params.sub_group {
        req_builder = req_builder.query(&[("subGroup", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AvailabilityResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AvailabilityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdAvailabilityGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdGetParams) -> Result<models::GroupUser, Error<ObjectGroupUsersObjectIdGetError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupUser`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupUser`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_group_post(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdGroupPostParams) -> Result<models::GroupCreateResponse, Error<ObjectGroupUsersObjectIdGroupPostError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/group", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.group_create);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupCreateResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupCreateResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdGroupPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_join_delete(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdJoinDeleteParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupUsersObjectIdJoinDeleteError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/join", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.group_membership_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMembershipResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMembershipResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdJoinDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_join_post(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdJoinPostParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupUsersObjectIdJoinPostError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/join", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.group_membership_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMembershipResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMembershipResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdJoinPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_recommended_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdRecommendedGetParams) -> Result<models::GroupSearchResponse, Error<ObjectGroupUsersObjectIdRecommendedGetError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/recommended", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdRecommendedGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_group_users_object_id_search_get(configuration: &configuration::Configuration, params: ObjectGroupUsersObjectIdSearchGetParams) -> Result<models::GroupSearchResponse, Error<ObjectGroupUsersObjectIdSearchGetError>> {

    let uri_str = format!("{}/object/group-users/{objectId}/search", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.score_min {
        req_builder = req_builder.query(&[("scoreMin", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort_field {
        req_builder = req_builder.query(&[("sortField", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.user_score {
        req_builder = req_builder.query(&[("userScore", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.has_slots {
        req_builder = req_builder.query(&[("hasSlots", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enrollment_types {
        req_builder = req_builder.query(&[("enrollmentTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.score_max {
        req_builder = req_builder.query(&[("scoreMax", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sub_group {
        req_builder = req_builder.query(&[("subGroup", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort_value {
        req_builder = req_builder.query(&[("sortValue", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("type", &params.r#type.to_string())]);
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupUsersObjectIdSearchGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_apply_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdApplyPostParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdApplyPostError>> {

    let uri_str = format!("{}/object/groups/{objectId}/apply", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.group_application);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdApplyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_delete(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDeleteParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdDeleteError>> {

    let uri_str = format!("{}/object/groups/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.disband_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_donations_claim_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDonationsClaimPutParams) -> Result<models::EmptyResponse, Error<ObjectGroupsObjectIdDonationsClaimPutError>> {

    let uri_str = format!("{}/object/groups/{objectId}/donations/claim", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdDonationsClaimPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_donations_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDonationsPostParams) -> Result<models::EmptyResponse, Error<ObjectGroupsObjectIdDonationsPostError>> {

    let uri_str = format!("{}/object/groups/{objectId}/donations", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_donation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdDonationsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_donations_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdDonationsPutParams) -> Result<models::EmptyResponse, Error<ObjectGroupsObjectIdDonationsPutError>> {

    let uri_str = format!("{}/object/groups/{objectId}/donations", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.make_donation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdDonationsPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_get(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdGetParams) -> Result<models::Group, Error<ObjectGroupsObjectIdGetError>> {

    let uri_str = format!("{}/object/groups/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_invite_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdInvitePostParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdInvitePostError>> {

    let uri_str = format!("{}/object/groups/{objectId}/invite", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.group_invite);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdInvitePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_kick_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdKickPostParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupsObjectIdKickPostError>> {

    let uri_str = format!("{}/object/groups/{objectId}/kick", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.kick_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMembershipResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMembershipResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdKickPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_member_delete(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdMemberDeleteParams) -> Result<models::GroupMembershipResponse, Error<ObjectGroupsObjectIdMemberDeleteError>> {

    let uri_str = format!("{}/object/groups/{objectId}/member", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.kick_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupMembershipResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupMembershipResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdMemberDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_petition_post(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdPetitionPostParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdPetitionPostError>> {

    let uri_str = format!("{}/object/groups/{objectId}/petition", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.group_application);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdPetitionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdPutParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdPutError>> {

    let uri_str = format!("{}/object/groups/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.group_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_groups_object_id_role_put(configuration: &configuration::Configuration, params: ObjectGroupsObjectIdRolePutParams) -> Result<models::CommonResponse, Error<ObjectGroupsObjectIdRolePutError>> {

    let uri_str = format!("{}/object/groups/{objectId}/role", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.role_change_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectGroupsObjectIdRolePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_get(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdGetParams) -> Result<models::InventoryView, Error<ObjectInventoryObjectIdGetError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InventoryView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InventoryView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_multipliers_get(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdMultipliersGetParams) -> Result<models::MultipliersGetResponse, Error<ObjectInventoryObjectIdMultipliersGetError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/multipliers", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MultipliersGetResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MultipliersGetResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdMultipliersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_post(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdPostParams) -> Result<models::InventoryView, Error<ObjectInventoryObjectIdPostError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.inventory_query_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::InventoryView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::InventoryView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_preview_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdPreviewPutParams) -> Result<models::PreviewVipBonusResponse, Error<ObjectInventoryObjectIdPreviewPutError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/preview", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.inventory_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PreviewVipBonusResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PreviewVipBonusResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdPreviewPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_proxy_reload_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdProxyReloadPutParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdProxyReloadPutError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/proxy/reload", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdProxyReloadPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdPutParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdPutError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.inventory_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_transaction_delete(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdTransactionDeleteParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdTransactionDeleteError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/transaction", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.end_transaction_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdTransactionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_inventory_object_id_transfer_put(configuration: &configuration::Configuration, params: ObjectInventoryObjectIdTransferPutParams) -> Result<models::CommonResponse, Error<ObjectInventoryObjectIdTransferPutError>> {

    let uri_str = format!("{}/object/inventory/{objectId}/transfer", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.transfer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectInventoryObjectIdTransferPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_assignment_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdAssignmentDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdAssignmentDeleteError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/assignment", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.leaderboard_remove_cache_entry_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdAssignmentDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_assignment_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdAssignmentGetParams) -> Result<models::LeaderboardAssignmentInfo, Error<ObjectLeaderboardsObjectIdAssignmentGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/assignment", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardAssignmentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardAssignmentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdAssignmentGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdDeleteError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_details_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdDetailsGetParams) -> Result<models::LeaderboardDetails, Error<ObjectLeaderboardsObjectIdDetailsGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/details", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardDetails`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardDetails`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdDetailsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_entries_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdEntriesDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdEntriesDeleteError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/entries", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdEntriesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_entry_delete(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdEntryDeleteParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdEntryDeleteError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/entry", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.leaderboard_remove_entry_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdEntryDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_entry_put(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdEntryPutParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdEntryPutError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/entry", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.leaderboard_add_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdEntryPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_freeze_put(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdFreezePutParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdFreezePutError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/freeze", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdFreezePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_friends_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdFriendsGetParams) -> Result<models::LeaderBoardViewResponse, Error<ObjectLeaderboardsObjectIdFriendsGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/friends", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderBoardViewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderBoardViewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdFriendsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_matches_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdMatchesGetParams) -> Result<models::MatchMakingMatchesPvpResponse, Error<ObjectLeaderboardsObjectIdMatchesGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/matches", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("poolSize", &params.pool_size.to_string())]);
    req_builder = req_builder.query(&[("windows", &params.windows.to_string())]);
    req_builder = req_builder.query(&[("windowSize", &params.window_size.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MatchMakingMatchesPvpResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MatchMakingMatchesPvpResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdMatchesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_membership_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdMembershipGetParams) -> Result<models::LeaderboardMembershipResponse, Error<ObjectLeaderboardsObjectIdMembershipGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/membership", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("playerId", &params.player_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardMembershipResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardMembershipResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdMembershipGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_partition_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdPartitionGetParams) -> Result<models::LeaderboardPartitionInfo, Error<ObjectLeaderboardsObjectIdPartitionGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/partition", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("playerId", &params.player_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderboardPartitionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderboardPartitionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdPartitionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_post(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdPostParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdPostError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.leaderboard_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_ranks_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdRanksGetParams) -> Result<models::LeaderBoardViewResponse, Error<ObjectLeaderboardsObjectIdRanksGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/ranks", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ids", &params.ids.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderBoardViewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderBoardViewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdRanksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_swap_put(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdSwapPutParams) -> Result<models::CommonResponse, Error<ObjectLeaderboardsObjectIdSwapPutError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/swap", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.leaderboard_swap_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CommonResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CommonResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdSwapPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_leaderboards_object_id_view_get(configuration: &configuration::Configuration, params: ObjectLeaderboardsObjectIdViewGetParams) -> Result<models::LeaderBoardViewResponse, Error<ObjectLeaderboardsObjectIdViewGetError>> {

    let uri_str = format!("{}/object/leaderboards/{objectId}/view", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.max {
        req_builder = req_builder.query(&[("max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.focus {
        req_builder = req_builder.query(&[("focus", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.friends {
        req_builder = req_builder.query(&[("friends", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.outlier {
        req_builder = req_builder.query(&[("outlier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.guild {
        req_builder = req_builder.query(&[("guild", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LeaderBoardViewResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LeaderBoardViewResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectLeaderboardsObjectIdViewGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_accept_many_put(configuration: &configuration::Configuration, params: ObjectMailObjectIdAcceptManyPutParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdAcceptManyPutError>> {

    let uri_str = format!("{}/object/mail/{objectId}/accept/many", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.accept_multiple_attachments);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdAcceptManyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_bulk_post(configuration: &configuration::Configuration, params: ObjectMailObjectIdBulkPostParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdBulkPostError>> {

    let uri_str = format!("{}/object/mail/{objectId}/bulk", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.bulk_send_mail_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdBulkPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_bulk_put(configuration: &configuration::Configuration, params: ObjectMailObjectIdBulkPutParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdBulkPutError>> {

    let uri_str = format!("{}/object/mail/{objectId}/bulk", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.bulk_update_mail_object_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdBulkPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_categories_get(configuration: &configuration::Configuration, params: ObjectMailObjectIdCategoriesGetParams) -> Result<models::ListMailCategoriesResponse, Error<ObjectMailObjectIdCategoriesGetError>> {

    let uri_str = format!("{}/object/mail/{objectId}/categories", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListMailCategoriesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListMailCategoriesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdCategoriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_detail_get(configuration: &configuration::Configuration, params: ObjectMailObjectIdDetailGetParams) -> Result<models::MailResponse, Error<ObjectMailObjectIdDetailGetError>> {

    let uri_str = format!("{}/object/mail/{objectId}/detail", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("mid", &params.mid.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdDetailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_get(configuration: &configuration::Configuration, params: ObjectMailObjectIdGetParams) -> Result<models::MailQueryResponse, Error<ObjectMailObjectIdGetError>> {

    let uri_str = format!("{}/object/mail/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailQueryResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailQueryResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_post(configuration: &configuration::Configuration, params: ObjectMailObjectIdPostParams) -> Result<models::SendMailResponse, Error<ObjectMailObjectIdPostError>> {

    let uri_str = format!("{}/object/mail/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.send_mail_object_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SendMailResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SendMailResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_put(configuration: &configuration::Configuration, params: ObjectMailObjectIdPutParams) -> Result<models::MailSuccessResponse, Error<ObjectMailObjectIdPutError>> {

    let uri_str = format!("{}/object/mail/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.update_mail_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSuccessResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSuccessResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_mail_object_id_search_post(configuration: &configuration::Configuration, params: ObjectMailObjectIdSearchPostParams) -> Result<models::MailSearchResponse, Error<ObjectMailObjectIdSearchPostError>> {

    let uri_str = format!("{}/object/mail/{objectId}/search", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.mail_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MailSearchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MailSearchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectMailObjectIdSearchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_stats_object_id_client_get(configuration: &configuration::Configuration, params: ObjectStatsObjectIdClientGetParams) -> Result<models::StatsResponse, Error<ObjectStatsObjectIdClientGetError>> {

    let uri_str = format!("{}/object/stats/{objectId}/client", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.stats {
        req_builder = req_builder.query(&[("stats", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectStatsObjectIdClientGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_stats_object_id_client_post(configuration: &configuration::Configuration, params: ObjectStatsObjectIdClientPostParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdClientPostError>> {

    let uri_str = format!("{}/object/stats/{objectId}/client", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stat_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectStatsObjectIdClientPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_stats_object_id_client_stringlist_post(configuration: &configuration::Configuration, params: ObjectStatsObjectIdClientStringlistPostParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdClientStringlistPostError>> {

    let uri_str = format!("{}/object/stats/{objectId}/client/stringlist", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stat_update_request_string_list_format);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectStatsObjectIdClientStringlistPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_stats_object_id_delete(configuration: &configuration::Configuration, params: ObjectStatsObjectIdDeleteParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdDeleteError>> {

    let uri_str = format!("{}/object/stats/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stat_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectStatsObjectIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_stats_object_id_get(configuration: &configuration::Configuration, params: ObjectStatsObjectIdGetParams) -> Result<models::StatsResponse, Error<ObjectStatsObjectIdGetError>> {

    let uri_str = format!("{}/object/stats/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.stats {
        req_builder = req_builder.query(&[("stats", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::StatsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::StatsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectStatsObjectIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_stats_object_id_post(configuration: &configuration::Configuration, params: ObjectStatsObjectIdPostParams) -> Result<models::EmptyResponse, Error<ObjectStatsObjectIdPostError>> {

    let uri_str = format!("{}/object/stats/{objectId}/", configuration.base_path, objectId=crate::apis::urlencode(params.object_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("X-BEAM-SCOPE", params.x_beam_scope.to_string());
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-DE-SIGNATURE", value);
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.stat_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmptyResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmptyResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectStatsObjectIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

