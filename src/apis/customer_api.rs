/*
 * Beamable API
 *
 * Autogenerated Beamable API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: support@beamable.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`api_customers_activate_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersActivatePutParams {
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_aliases_alias_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersAliasesAliasGetParams {
    pub alias: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_alias_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdAliasPutParams {
    pub customer_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub set_customer_alias_request: Option<models::SetCustomerAliasRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_games_game_id_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdGamesGameIdGetParams {
    pub customer_id: String,
    pub game_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_games_game_id_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdGamesGameIdPutParams {
    pub customer_id: String,
    pub game_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub customer_actor_update_game_hierarchy_request: Option<models::CustomerActorUpdateGameHierarchyRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_games_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdGamesGetParams {
    pub customer_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_games_post`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdGamesPostParams {
    pub customer_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub new_game_request: Option<models::NewGameRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdGetParams {
    pub customer_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdPutParams {
    pub customer_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub update_customer_request: Option<models::UpdateCustomerRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_destination_realm_id_promotion_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionGetParams {
    pub customer_id: String,
    pub destination_realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub source_realm_id: Option<String>,
    pub promotables: Option<String>,
    pub content_ids: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_destination_realm_id_promotion_post`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionPostParams {
    pub customer_id: String,
    pub destination_realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub customer_actor_promote_realm_request: Option<models::CustomerActorPromoteRealmRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_post`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsPostParams {
    pub customer_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub create_realm_request: Option<models::CreateRealmRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_client_defaults_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdClientDefaultsGetParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_config_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdConfigGetParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_config_patch`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdConfigPatchParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub realm_config_change_request: Option<models::RealmConfigChangeRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_config_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdConfigPutParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub customer_actor_realm_config_save_request: Option<models::CustomerActorRealmConfigSaveRequest>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_delete`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdDeleteParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdGetParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdPutParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_customer_id_realms_realm_id_rename_put`]
#[derive(Clone, Debug)]
pub struct ApiCustomersCustomerIdRealmsRealmIdRenamePutParams {
    pub customer_id: String,
    pub realm_id: String,
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub rename_realm_request: Option<models::RenameRealmRequest>
}

/// struct for passing parameters to the method [`api_customers_get`]
#[derive(Clone, Debug)]
pub struct ApiCustomersGetParams {
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>
}

/// struct for passing parameters to the method [`api_customers_post`]
#[derive(Clone, Debug)]
pub struct ApiCustomersPostParams {
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub customer_actor_new_customer_request: Option<models::CustomerActorNewCustomerRequest>
}

/// struct for passing parameters to the method [`api_customers_verify_post`]
#[derive(Clone, Debug)]
pub struct ApiCustomersVerifyPostParams {
    /// Customer and project scope. This should be in the form of '{customerId}.{projectId}'. This is only necessary when not using a JWT bearer token
    pub x_beam_scope: Option<String>,
    /// Override the playerId of the requester. This is only necessary when not using a JWT bearer token.
    pub x_beam_gamertag: Option<String>,
    pub customer_actor_new_customer_request: Option<models::CustomerActorNewCustomerRequest>
}


/// struct for typed errors of method [`api_customers_activate_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersActivatePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_aliases_alias_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersAliasesAliasGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_alias_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdAliasPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_games_game_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdGamesGameIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_games_game_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdGamesGameIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_games_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdGamesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_games_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdGamesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_destination_realm_id_promotion_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_destination_realm_id_promotion_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_client_defaults_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdClientDefaultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdConfigGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_config_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdConfigPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_config_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdConfigPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_customer_id_realms_realm_id_rename_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersCustomerIdRealmsRealmIdRenamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_customers_verify_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiCustomersVerifyPostError {
    UnknownValue(serde_json::Value),
}


pub async fn api_customers_activate_put(configuration: &configuration::Configuration, params: ApiCustomersActivatePutParams) -> Result<models::CustomerActorHtmlResponse, Error<ApiCustomersActivatePutError>> {

    let uri_str = format!("{}/api/customers/activate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorHtmlResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorHtmlResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersActivatePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_aliases_alias_get(configuration: &configuration::Configuration, params: ApiCustomersAliasesAliasGetParams) -> Result<models::CustomerActorAliasAvailableResponse, Error<ApiCustomersAliasesAliasGetError>> {

    let uri_str = format!("{}/api/customers/aliases/{alias}", configuration.base_path, alias=crate::apis::urlencode(params.alias));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorAliasAvailableResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorAliasAvailableResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersAliasesAliasGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_alias_put(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdAliasPutParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdAliasPutError>> {

    let uri_str = format!("{}/api/customers/{customerId}/alias", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.set_customer_alias_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdAliasPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_games_game_id_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdGamesGameIdGetParams) -> Result<models::GetGamesResponse, Error<ApiCustomersCustomerIdGamesGameIdGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}/games/{gameId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), gameId=crate::apis::urlencode(params.game_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGamesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGamesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdGamesGameIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_games_game_id_put(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdGamesGameIdPutParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdGamesGameIdPutError>> {

    let uri_str = format!("{}/api/customers/{customerId}/games/{gameId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), gameId=crate::apis::urlencode(params.game_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.customer_actor_update_game_hierarchy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdGamesGameIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_games_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdGamesGetParams) -> Result<models::GetGamesResponse, Error<ApiCustomersCustomerIdGamesGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}/games", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetGamesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetGamesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdGamesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_games_post(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdGamesPostParams) -> Result<models::RealmView, Error<ApiCustomersCustomerIdGamesPostError>> {

    let uri_str = format!("{}/api/customers/{customerId}/games", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.new_game_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RealmView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RealmView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdGamesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdGetParams) -> Result<models::CustomerActorCustomerView, Error<ApiCustomersCustomerIdGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorCustomerView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorCustomerView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_put(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdPutParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdPutError>> {

    let uri_str = format!("{}/api/customers/{customerId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.update_customer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_destination_realm_id_promotion_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionGetParams) -> Result<models::CustomerActorPromoteRealmResponse, Error<ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{destinationRealmId}/promotion", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), destinationRealmId=crate::apis::urlencode(params.destination_realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.source_realm_id {
        req_builder = req_builder.query(&[("sourceRealmId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.promotables {
        req_builder = req_builder.query(&[("promotables", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.content_ids {
        req_builder = req_builder.query(&[("contentIds", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorPromoteRealmResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorPromoteRealmResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_destination_realm_id_promotion_post(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionPostParams) -> Result<models::CustomerActorPromoteRealmResponse, Error<ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionPostError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{destinationRealmId}/promotion", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), destinationRealmId=crate::apis::urlencode(params.destination_realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.customer_actor_promote_realm_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorPromoteRealmResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorPromoteRealmResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsDestinationRealmIdPromotionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_post(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsPostParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdRealmsPostError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.create_realm_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_client_defaults_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdClientDefaultsGetParams) -> Result<models::CustomerActorRealmConfiguration, Error<ApiCustomersCustomerIdRealmsRealmIdClientDefaultsGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}/client-defaults", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorRealmConfiguration`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorRealmConfiguration`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdClientDefaultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_config_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdConfigGetParams) -> Result<models::CustomerActorRealmConfigResponse, Error<ApiCustomersCustomerIdRealmsRealmIdConfigGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}/config", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorRealmConfigResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorRealmConfigResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_config_patch(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdConfigPatchParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdRealmsRealmIdConfigPatchError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}/config", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.realm_config_change_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdConfigPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_config_put(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdConfigPutParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdRealmsRealmIdConfigPutError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}/config", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.customer_actor_realm_config_save_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdConfigPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_delete(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdDeleteParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdRealmsRealmIdDeleteError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_get(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdGetParams) -> Result<models::RealmView, Error<ApiCustomersCustomerIdRealmsRealmIdGetError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RealmView`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RealmView`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_put(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdPutParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdRealmsRealmIdPutError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_customer_id_realms_realm_id_rename_put(configuration: &configuration::Configuration, params: ApiCustomersCustomerIdRealmsRealmIdRenamePutParams) -> Result<serde_json::Value, Error<ApiCustomersCustomerIdRealmsRealmIdRenamePutError>> {

    let uri_str = format!("{}/api/customers/{customerId}/realms/{realmId}/rename", configuration.base_path, customerId=crate::apis::urlencode(params.customer_id), realmId=crate::apis::urlencode(params.realm_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.rename_realm_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersCustomerIdRealmsRealmIdRenamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_get(configuration: &configuration::Configuration, params: ApiCustomersGetParams) -> Result<models::CustomerActorCustomersResponse, Error<ApiCustomersGetError>> {

    let uri_str = format!("{}/api/customers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorCustomersResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorCustomersResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_post(configuration: &configuration::Configuration, params: ApiCustomersPostParams) -> Result<models::CustomerActorNewCustomerResponse, Error<ApiCustomersPostError>> {

    let uri_str = format!("{}/api/customers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.customer_actor_new_customer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorNewCustomerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorNewCustomerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_customers_verify_post(configuration: &configuration::Configuration, params: ApiCustomersVerifyPostParams) -> Result<models::CustomerActorNewCustomerResponse, Error<ApiCustomersVerifyPostError>> {

    let uri_str = format!("{}/api/customers/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.x_beam_scope {
        req_builder = req_builder.header("X-BEAM-SCOPE", param_value.to_string());
    }
    if let Some(param_value) = params.x_beam_gamertag {
        req_builder = req_builder.header("X-BEAM-GAMERTAG", param_value.to_string());
    }
    req_builder = req_builder.json(&params.customer_actor_new_customer_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CustomerActorNewCustomerResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CustomerActorNewCustomerResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiCustomersVerifyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

